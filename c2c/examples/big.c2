/*
    This is snake example with copied/renamed functions to make a big program
*/
module big;

import stdio as io;
import string local;

#define ANSI_BLACK    "\033[0;30m"
#define ANSI_RED      "\033[0;31m"
#define ANSI_GREEN    "\033[0;32m"
#define ANSI_YELLOW   "\033[0;33m"
#define ANSI_BLUE     "\033[0;34m"
#define ANSI_MAGENTA  "\033[0;35m"
#define ANSI_CYAN     "\033[0;36m"
#define ANSI_GREY     "\033[0;37m"
#define ANSI_DARKGREY "\033[01;30m"
#define ANSI_BRED     "\033[01;31m"
#define ANSI_BGREEN   "\033[01;32m"
#define ANSI_BYELLOW  "\033[01;33m"
#define ANSI_BBLUE    "\033[01;34m"
#define ANSI_BMAGENTA "\033[01;35m"
#define ANSI_BCYAN    "\033[01;36m"
#define ANSI_WHITE    "\033[01;37m"
#define ANSI_NORMAL   "\033[0m"


public func int32 main() {
    aaa_calculate_rotations();
    aaa_board_init();
    aaa_board_try_piece(0);
    io.printf("%luM tries, found %d solutions\n", aaa_tried/1000000, aaa_found);
    return 0;
}

type Flags enum int8 {
    NORTH = 1,
    EAST  = 2,
    SOUTH = 3,
    WEST  = 4,
    HEAD  = 5,
    TAIL  = 6,
}

type FieldStatus enum int8 {
    FIELD_FREE = 0,
    FIELD_BLOCKED,
    FIELD_TAKEN,    // + index of piece
}

// ----------------------------------------------

type aaa_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 aaa_found;
uint64 aaa_tried;

type aaa_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type aaa_Board struct {
    aaa_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type aaa_Piece struct {
    aaa_Coor[4] side1;
    aaa_Coor[4] side2;
}

type aaa_Option struct {
    aaa_Coor[4] parts;
}

aaa_Board aaa_board;

aaa_Piece[] aaa_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
aaa_Option[aaa_num_options][aaa_num_pieces] aaa_options;

const int32 aaa_num_pieces = elemsof(aaa_pieces);
const int32 aaa_num_options = 8;


func aaa_Coor aaa_coor_rotate(aaa_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    aaa_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void aaa_calculate_rotations() {
    memset(aaa_options, 0, sizeof(aaa_options));
    for (uint32 p=0; p<aaa_num_pieces; p++) {
        const aaa_Piece* P = &aaa_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            aaa_Option* O1 = &aaa_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                aaa_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = aaa_coor_rotate(c, o);
            }
            aaa_Option* O2 = &aaa_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                aaa_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = aaa_coor_rotate(c, o);
            }
        }
    }
}

func void aaa_board_set(int32 x, int32 y, aaa_Field field) {
    aaa_board.fields[x + y * 5] = field;
}

func aaa_Field aaa_board_get(int32 x, int32 y) {
    return aaa_board.fields[x + y * 5];
}

func void aaa_board_init() {
    aaa_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            aaa_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    aaa_board_set(0, 4, f);
    aaa_board.haveHead = 0;
    aaa_board.haveTail = 0;
}

func char aaa_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void aaa_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", aaa_board.haveHead, aaa_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            aaa_Field field = aaa_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, aaa_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, aaa_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = aaa_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 aaa_board_check_fault(int32 xx, int32 yy, int32 expect) {
    aaa_Field F = aaa_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 aaa_board_try_option(const aaa_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        aaa_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        aaa_Field F = aaa_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (aaa_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (aaa_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (aaa_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (aaa_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (aaa_board.haveHead) return 1;
            break;
        case TAIL:
            if (aaa_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void aaa_board_clearflags(int32 x, int32 y) {
    aaa_board.fields[x + y * 5].expected = 0;
}

func void aaa_board_setExpected(int32 x, int32 y, uint8 side) {
    aaa_board.fields[x + y * 5].expected = side;
}

func void aaa_board_add(const aaa_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        aaa_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        aaa_Field field = aaa_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        aaa_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            aaa_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            aaa_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            aaa_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            aaa_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            aaa_board.haveHead = 1;
            break;
        case TAIL:
            aaa_board.haveTail = 1;
            break;
        }
    }
}

func void aaa_board_rem(const aaa_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        aaa_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        aaa_Field field = aaa_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        aaa_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            aaa_board_clearflags(xx, yy+1);
            break;
        case EAST:
            aaa_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            aaa_board_clearflags(xx, yy-1);
            break;
        case WEST:
            aaa_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            aaa_board.haveHead = 0;
            break;
        case TAIL:
            aaa_board.haveTail = 0;
            break;
        }
    }
}

func void aaa_board_try_piece(uint8 p) {
    if (p == aaa_num_pieces) {
        aaa_found++;
        io.printf("Found solution %u\n", aaa_found);
        aaa_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            aaa_Field F = aaa_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<aaa_num_options; o++) {
                if (!aaa_board_try_option(&aaa_options[o][p], x, y)) {
                    aaa_board_add(&aaa_options[o][p], x, y, p);
                    aaa_board_try_piece(p+1);
                    aaa_board_rem(&aaa_options[o][p], x, y);
                }
                aaa_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE bbb ------------------------------------------

type bbb_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 bbb_found;
uint64 bbb_tried;

type bbb_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type bbb_Board struct {
    bbb_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type bbb_Piece struct {
    bbb_Coor[4] side1;
    bbb_Coor[4] side2;
}

type bbb_Option struct {
    bbb_Coor[4] parts;
}

bbb_Board bbb_board;

bbb_Piece[] bbb_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
bbb_Option[bbb_num_options][bbb_num_pieces] bbb_options;

const int32 bbb_num_pieces = elemsof(bbb_pieces);
const int32 bbb_num_options = 8;


func bbb_Coor bbb_coor_rotate(bbb_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    bbb_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void bbb_calculate_rotations() {
    memset(bbb_options, 0, sizeof(bbb_options));
    for (uint32 p=0; p<bbb_num_pieces; p++) {
        const bbb_Piece* P = &bbb_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            bbb_Option* O1 = &bbb_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                bbb_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = bbb_coor_rotate(c, o);
            }
            bbb_Option* O2 = &bbb_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                bbb_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = bbb_coor_rotate(c, o);
            }
        }
    }
}

func void bbb_board_set(int32 x, int32 y, bbb_Field field) {
    bbb_board.fields[x + y * 5] = field;
}

func bbb_Field bbb_board_get(int32 x, int32 y) {
    return bbb_board.fields[x + y * 5];
}

func void bbb_board_init() {
    bbb_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            bbb_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    bbb_board_set(0, 4, f);
    bbb_board.haveHead = 0;
    bbb_board.haveTail = 0;
}

func char bbb_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void bbb_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", bbb_board.haveHead, bbb_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            bbb_Field field = bbb_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, bbb_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, bbb_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = bbb_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 bbb_board_check_fault(int32 xx, int32 yy, int32 expect) {
    bbb_Field F = bbb_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 bbb_board_try_option(const bbb_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        bbb_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        bbb_Field F = bbb_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (bbb_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (bbb_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (bbb_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (bbb_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (bbb_board.haveHead) return 1;
            break;
        case TAIL:
            if (bbb_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void bbb_board_clearflags(int32 x, int32 y) {
    bbb_board.fields[x + y * 5].expected = 0;
}

func void bbb_board_setExpected(int32 x, int32 y, uint8 side) {
    bbb_board.fields[x + y * 5].expected = side;
}

func void bbb_board_add(const bbb_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        bbb_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        bbb_Field field = bbb_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        bbb_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            bbb_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            bbb_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            bbb_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            bbb_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            bbb_board.haveHead = 1;
            break;
        case TAIL:
            bbb_board.haveTail = 1;
            break;
        }
    }
}

func void bbb_board_rem(const bbb_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        bbb_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        bbb_Field field = bbb_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        bbb_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            bbb_board_clearflags(xx, yy+1);
            break;
        case EAST:
            bbb_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            bbb_board_clearflags(xx, yy-1);
            break;
        case WEST:
            bbb_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            bbb_board.haveHead = 0;
            break;
        case TAIL:
            bbb_board.haveTail = 0;
            break;
        }
    }
}

func void bbb_board_try_piece(uint8 p) {
    if (p == bbb_num_pieces) {
        bbb_found++;
        io.printf("Found solution %u\n", bbb_found);
        bbb_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            bbb_Field F = bbb_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<bbb_num_options; o++) {
                if (!bbb_board_try_option(&bbb_options[o][p], x, y)) {
                    bbb_board_add(&bbb_options[o][p], x, y, p);
                    bbb_board_try_piece(p+1);
                    bbb_board_rem(&bbb_options[o][p], x, y);
                }
                bbb_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ccc ------------------------------------------

type ccc_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 ccc_found;
uint64 ccc_tried;

type ccc_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type ccc_Board struct {
    ccc_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type ccc_Piece struct {
    ccc_Coor[4] side1;
    ccc_Coor[4] side2;
}

type ccc_Option struct {
    ccc_Coor[4] parts;
}

ccc_Board ccc_board;

ccc_Piece[] ccc_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
ccc_Option[ccc_num_options][ccc_num_pieces] ccc_options;

const int32 ccc_num_pieces = elemsof(ccc_pieces);
const int32 ccc_num_options = 8;


func ccc_Coor ccc_coor_rotate(ccc_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    ccc_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ccc_calculate_rotations() {
    memset(ccc_options, 0, sizeof(ccc_options));
    for (uint32 p=0; p<ccc_num_pieces; p++) {
        const ccc_Piece* P = &ccc_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            ccc_Option* O1 = &ccc_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                ccc_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = ccc_coor_rotate(c, o);
            }
            ccc_Option* O2 = &ccc_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                ccc_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = ccc_coor_rotate(c, o);
            }
        }
    }
}

func void ccc_board_set(int32 x, int32 y, ccc_Field field) {
    ccc_board.fields[x + y * 5] = field;
}

func ccc_Field ccc_board_get(int32 x, int32 y) {
    return ccc_board.fields[x + y * 5];
}

func void ccc_board_init() {
    ccc_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            ccc_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    ccc_board_set(0, 4, f);
    ccc_board.haveHead = 0;
    ccc_board.haveTail = 0;
}

func char ccc_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void ccc_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ccc_board.haveHead, ccc_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            ccc_Field field = ccc_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ccc_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ccc_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ccc_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 ccc_board_check_fault(int32 xx, int32 yy, int32 expect) {
    ccc_Field F = ccc_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 ccc_board_try_option(const ccc_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ccc_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        ccc_Field F = ccc_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (ccc_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (ccc_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (ccc_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (ccc_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (ccc_board.haveHead) return 1;
            break;
        case TAIL:
            if (ccc_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ccc_board_clearflags(int32 x, int32 y) {
    ccc_board.fields[x + y * 5].expected = 0;
}

func void ccc_board_setExpected(int32 x, int32 y, uint8 side) {
    ccc_board.fields[x + y * 5].expected = side;
}

func void ccc_board_add(const ccc_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        ccc_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ccc_Field field = ccc_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        ccc_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ccc_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            ccc_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            ccc_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            ccc_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            ccc_board.haveHead = 1;
            break;
        case TAIL:
            ccc_board.haveTail = 1;
            break;
        }
    }
}

func void ccc_board_rem(const ccc_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ccc_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ccc_Field field = ccc_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        ccc_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ccc_board_clearflags(xx, yy+1);
            break;
        case EAST:
            ccc_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            ccc_board_clearflags(xx, yy-1);
            break;
        case WEST:
            ccc_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            ccc_board.haveHead = 0;
            break;
        case TAIL:
            ccc_board.haveTail = 0;
            break;
        }
    }
}

func void ccc_board_try_piece(uint8 p) {
    if (p == ccc_num_pieces) {
        ccc_found++;
        io.printf("Found solution %u\n", ccc_found);
        ccc_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            ccc_Field F = ccc_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<ccc_num_options; o++) {
                if (!ccc_board_try_option(&ccc_options[o][p], x, y)) {
                    ccc_board_add(&ccc_options[o][p], x, y, p);
                    ccc_board_try_piece(p+1);
                    ccc_board_rem(&ccc_options[o][p], x, y);
                }
                ccc_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ddd ------------------------------------------

type ddd_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 ddd_found;
uint64 ddd_tried;

type ddd_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type ddd_Board struct {
    ddd_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type ddd_Piece struct {
    ddd_Coor[4] side1;
    ddd_Coor[4] side2;
}

type ddd_Option struct {
    ddd_Coor[4] parts;
}

ddd_Board ddd_board;

ddd_Piece[] ddd_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
ddd_Option[ddd_num_options][ddd_num_pieces] ddd_options;

const int32 ddd_num_pieces = elemsof(ddd_pieces);
const int32 ddd_num_options = 8;


func ddd_Coor ddd_coor_rotate(ddd_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    ddd_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ddd_calculate_rotations() {
    memset(ddd_options, 0, sizeof(ddd_options));
    for (uint32 p=0; p<ddd_num_pieces; p++) {
        const ddd_Piece* P = &ddd_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            ddd_Option* O1 = &ddd_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                ddd_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = ddd_coor_rotate(c, o);
            }
            ddd_Option* O2 = &ddd_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                ddd_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = ddd_coor_rotate(c, o);
            }
        }
    }
}

func void ddd_board_set(int32 x, int32 y, ddd_Field field) {
    ddd_board.fields[x + y * 5] = field;
}

func ddd_Field ddd_board_get(int32 x, int32 y) {
    return ddd_board.fields[x + y * 5];
}

func void ddd_board_init() {
    ddd_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            ddd_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    ddd_board_set(0, 4, f);
    ddd_board.haveHead = 0;
    ddd_board.haveTail = 0;
}

func char ddd_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void ddd_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ddd_board.haveHead, ddd_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            ddd_Field field = ddd_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ddd_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ddd_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ddd_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 ddd_board_check_fault(int32 xx, int32 yy, int32 expect) {
    ddd_Field F = ddd_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 ddd_board_try_option(const ddd_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ddd_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        ddd_Field F = ddd_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (ddd_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (ddd_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (ddd_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (ddd_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (ddd_board.haveHead) return 1;
            break;
        case TAIL:
            if (ddd_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ddd_board_clearflags(int32 x, int32 y) {
    ddd_board.fields[x + y * 5].expected = 0;
}

func void ddd_board_setExpected(int32 x, int32 y, uint8 side) {
    ddd_board.fields[x + y * 5].expected = side;
}

func void ddd_board_add(const ddd_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        ddd_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ddd_Field field = ddd_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        ddd_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ddd_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            ddd_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            ddd_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            ddd_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            ddd_board.haveHead = 1;
            break;
        case TAIL:
            ddd_board.haveTail = 1;
            break;
        }
    }
}

func void ddd_board_rem(const ddd_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ddd_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ddd_Field field = ddd_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        ddd_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ddd_board_clearflags(xx, yy+1);
            break;
        case EAST:
            ddd_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            ddd_board_clearflags(xx, yy-1);
            break;
        case WEST:
            ddd_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            ddd_board.haveHead = 0;
            break;
        case TAIL:
            ddd_board.haveTail = 0;
            break;
        }
    }
}

func void ddd_board_try_piece(uint8 p) {
    if (p == ddd_num_pieces) {
        ddd_found++;
        io.printf("Found solution %u\n", ddd_found);
        ddd_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            ddd_Field F = ddd_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<ddd_num_options; o++) {
                if (!ddd_board_try_option(&ddd_options[o][p], x, y)) {
                    ddd_board_add(&ddd_options[o][p], x, y, p);
                    ddd_board_try_piece(p+1);
                    ddd_board_rem(&ddd_options[o][p], x, y);
                }
                ddd_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE eee ------------------------------------------

type eee_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 eee_found;
uint64 eee_tried;

type eee_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type eee_Board struct {
    eee_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type eee_Piece struct {
    eee_Coor[4] side1;
    eee_Coor[4] side2;
}

type eee_Option struct {
    eee_Coor[4] parts;
}

eee_Board eee_board;

eee_Piece[] eee_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
eee_Option[eee_num_options][eee_num_pieces] eee_options;

const int32 eee_num_pieces = elemsof(eee_pieces);
const int32 eee_num_options = 8;


func eee_Coor eee_coor_rotate(eee_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    eee_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void eee_calculate_rotations() {
    memset(eee_options, 0, sizeof(eee_options));
    for (uint32 p=0; p<eee_num_pieces; p++) {
        const eee_Piece* P = &eee_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            eee_Option* O1 = &eee_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                eee_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = eee_coor_rotate(c, o);
            }
            eee_Option* O2 = &eee_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                eee_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = eee_coor_rotate(c, o);
            }
        }
    }
}

func void eee_board_set(int32 x, int32 y, eee_Field field) {
    eee_board.fields[x + y * 5] = field;
}

func eee_Field eee_board_get(int32 x, int32 y) {
    return eee_board.fields[x + y * 5];
}

func void eee_board_init() {
    eee_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            eee_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    eee_board_set(0, 4, f);
    eee_board.haveHead = 0;
    eee_board.haveTail = 0;
}

func char eee_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void eee_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", eee_board.haveHead, eee_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            eee_Field field = eee_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, eee_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, eee_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = eee_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 eee_board_check_fault(int32 xx, int32 yy, int32 expect) {
    eee_Field F = eee_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 eee_board_try_option(const eee_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        eee_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        eee_Field F = eee_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (eee_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (eee_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (eee_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (eee_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (eee_board.haveHead) return 1;
            break;
        case TAIL:
            if (eee_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void eee_board_clearflags(int32 x, int32 y) {
    eee_board.fields[x + y * 5].expected = 0;
}

func void eee_board_setExpected(int32 x, int32 y, uint8 side) {
    eee_board.fields[x + y * 5].expected = side;
}

func void eee_board_add(const eee_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        eee_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        eee_Field field = eee_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        eee_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            eee_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            eee_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            eee_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            eee_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            eee_board.haveHead = 1;
            break;
        case TAIL:
            eee_board.haveTail = 1;
            break;
        }
    }
}

func void eee_board_rem(const eee_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        eee_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        eee_Field field = eee_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        eee_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            eee_board_clearflags(xx, yy+1);
            break;
        case EAST:
            eee_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            eee_board_clearflags(xx, yy-1);
            break;
        case WEST:
            eee_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            eee_board.haveHead = 0;
            break;
        case TAIL:
            eee_board.haveTail = 0;
            break;
        }
    }
}

func void eee_board_try_piece(uint8 p) {
    if (p == eee_num_pieces) {
        eee_found++;
        io.printf("Found solution %u\n", eee_found);
        eee_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            eee_Field F = eee_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<eee_num_options; o++) {
                if (!eee_board_try_option(&eee_options[o][p], x, y)) {
                    eee_board_add(&eee_options[o][p], x, y, p);
                    eee_board_try_piece(p+1);
                    eee_board_rem(&eee_options[o][p], x, y);
                }
                eee_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE fff ------------------------------------------

type fff_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 fff_found;
uint64 fff_tried;

type fff_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type fff_Board struct {
    fff_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type fff_Piece struct {
    fff_Coor[4] side1;
    fff_Coor[4] side2;
}

type fff_Option struct {
    fff_Coor[4] parts;
}

fff_Board fff_board;

fff_Piece[] fff_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
fff_Option[fff_num_options][fff_num_pieces] fff_options;

const int32 fff_num_pieces = elemsof(fff_pieces);
const int32 fff_num_options = 8;


func fff_Coor fff_coor_rotate(fff_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    fff_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void fff_calculate_rotations() {
    memset(fff_options, 0, sizeof(fff_options));
    for (uint32 p=0; p<fff_num_pieces; p++) {
        const fff_Piece* P = &fff_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            fff_Option* O1 = &fff_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                fff_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = fff_coor_rotate(c, o);
            }
            fff_Option* O2 = &fff_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                fff_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = fff_coor_rotate(c, o);
            }
        }
    }
}

func void fff_board_set(int32 x, int32 y, fff_Field field) {
    fff_board.fields[x + y * 5] = field;
}

func fff_Field fff_board_get(int32 x, int32 y) {
    return fff_board.fields[x + y * 5];
}

func void fff_board_init() {
    fff_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            fff_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    fff_board_set(0, 4, f);
    fff_board.haveHead = 0;
    fff_board.haveTail = 0;
}

func char fff_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void fff_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", fff_board.haveHead, fff_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            fff_Field field = fff_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, fff_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, fff_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = fff_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 fff_board_check_fault(int32 xx, int32 yy, int32 expect) {
    fff_Field F = fff_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 fff_board_try_option(const fff_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        fff_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        fff_Field F = fff_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (fff_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (fff_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (fff_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (fff_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (fff_board.haveHead) return 1;
            break;
        case TAIL:
            if (fff_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void fff_board_clearflags(int32 x, int32 y) {
    fff_board.fields[x + y * 5].expected = 0;
}

func void fff_board_setExpected(int32 x, int32 y, uint8 side) {
    fff_board.fields[x + y * 5].expected = side;
}

func void fff_board_add(const fff_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        fff_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        fff_Field field = fff_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        fff_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            fff_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            fff_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            fff_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            fff_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            fff_board.haveHead = 1;
            break;
        case TAIL:
            fff_board.haveTail = 1;
            break;
        }
    }
}

func void fff_board_rem(const fff_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        fff_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        fff_Field field = fff_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        fff_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            fff_board_clearflags(xx, yy+1);
            break;
        case EAST:
            fff_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            fff_board_clearflags(xx, yy-1);
            break;
        case WEST:
            fff_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            fff_board.haveHead = 0;
            break;
        case TAIL:
            fff_board.haveTail = 0;
            break;
        }
    }
}

func void fff_board_try_piece(uint8 p) {
    if (p == fff_num_pieces) {
        fff_found++;
        io.printf("Found solution %u\n", fff_found);
        fff_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            fff_Field F = fff_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<fff_num_options; o++) {
                if (!fff_board_try_option(&fff_options[o][p], x, y)) {
                    fff_board_add(&fff_options[o][p], x, y, p);
                    fff_board_try_piece(p+1);
                    fff_board_rem(&fff_options[o][p], x, y);
                }
                fff_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ggg ------------------------------------------

type ggg_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 ggg_found;
uint64 ggg_tried;

type ggg_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type ggg_Board struct {
    ggg_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type ggg_Piece struct {
    ggg_Coor[4] side1;
    ggg_Coor[4] side2;
}

type ggg_Option struct {
    ggg_Coor[4] parts;
}

ggg_Board ggg_board;

ggg_Piece[] ggg_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
ggg_Option[ggg_num_options][ggg_num_pieces] ggg_options;

const int32 ggg_num_pieces = elemsof(ggg_pieces);
const int32 ggg_num_options = 8;


func ggg_Coor ggg_coor_rotate(ggg_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    ggg_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ggg_calculate_rotations() {
    memset(ggg_options, 0, sizeof(ggg_options));
    for (uint32 p=0; p<ggg_num_pieces; p++) {
        const ggg_Piece* P = &ggg_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            ggg_Option* O1 = &ggg_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                ggg_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = ggg_coor_rotate(c, o);
            }
            ggg_Option* O2 = &ggg_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                ggg_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = ggg_coor_rotate(c, o);
            }
        }
    }
}

func void ggg_board_set(int32 x, int32 y, ggg_Field field) {
    ggg_board.fields[x + y * 5] = field;
}

func ggg_Field ggg_board_get(int32 x, int32 y) {
    return ggg_board.fields[x + y * 5];
}

func void ggg_board_init() {
    ggg_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            ggg_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    ggg_board_set(0, 4, f);
    ggg_board.haveHead = 0;
    ggg_board.haveTail = 0;
}

func char ggg_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void ggg_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ggg_board.haveHead, ggg_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            ggg_Field field = ggg_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ggg_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ggg_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ggg_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 ggg_board_check_fault(int32 xx, int32 yy, int32 expect) {
    ggg_Field F = ggg_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 ggg_board_try_option(const ggg_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ggg_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        ggg_Field F = ggg_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (ggg_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (ggg_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (ggg_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (ggg_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (ggg_board.haveHead) return 1;
            break;
        case TAIL:
            if (ggg_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ggg_board_clearflags(int32 x, int32 y) {
    ggg_board.fields[x + y * 5].expected = 0;
}

func void ggg_board_setExpected(int32 x, int32 y, uint8 side) {
    ggg_board.fields[x + y * 5].expected = side;
}

func void ggg_board_add(const ggg_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        ggg_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ggg_Field field = ggg_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        ggg_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ggg_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            ggg_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            ggg_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            ggg_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            ggg_board.haveHead = 1;
            break;
        case TAIL:
            ggg_board.haveTail = 1;
            break;
        }
    }
}

func void ggg_board_rem(const ggg_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ggg_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ggg_Field field = ggg_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        ggg_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ggg_board_clearflags(xx, yy+1);
            break;
        case EAST:
            ggg_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            ggg_board_clearflags(xx, yy-1);
            break;
        case WEST:
            ggg_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            ggg_board.haveHead = 0;
            break;
        case TAIL:
            ggg_board.haveTail = 0;
            break;
        }
    }
}

func void ggg_board_try_piece(uint8 p) {
    if (p == ggg_num_pieces) {
        ggg_found++;
        io.printf("Found solution %u\n", ggg_found);
        ggg_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            ggg_Field F = ggg_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<ggg_num_options; o++) {
                if (!ggg_board_try_option(&ggg_options[o][p], x, y)) {
                    ggg_board_add(&ggg_options[o][p], x, y, p);
                    ggg_board_try_piece(p+1);
                    ggg_board_rem(&ggg_options[o][p], x, y);
                }
                ggg_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE hhh ------------------------------------------

type hhh_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 hhh_found;
uint64 hhh_tried;

type hhh_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type hhh_Board struct {
    hhh_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type hhh_Piece struct {
    hhh_Coor[4] side1;
    hhh_Coor[4] side2;
}

type hhh_Option struct {
    hhh_Coor[4] parts;
}

hhh_Board hhh_board;

hhh_Piece[] hhh_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
hhh_Option[hhh_num_options][hhh_num_pieces] hhh_options;

const int32 hhh_num_pieces = elemsof(hhh_pieces);
const int32 hhh_num_options = 8;


func hhh_Coor hhh_coor_rotate(hhh_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    hhh_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void hhh_calculate_rotations() {
    memset(hhh_options, 0, sizeof(hhh_options));
    for (uint32 p=0; p<hhh_num_pieces; p++) {
        const hhh_Piece* P = &hhh_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            hhh_Option* O1 = &hhh_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                hhh_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = hhh_coor_rotate(c, o);
            }
            hhh_Option* O2 = &hhh_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                hhh_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = hhh_coor_rotate(c, o);
            }
        }
    }
}

func void hhh_board_set(int32 x, int32 y, hhh_Field field) {
    hhh_board.fields[x + y * 5] = field;
}

func hhh_Field hhh_board_get(int32 x, int32 y) {
    return hhh_board.fields[x + y * 5];
}

func void hhh_board_init() {
    hhh_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            hhh_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    hhh_board_set(0, 4, f);
    hhh_board.haveHead = 0;
    hhh_board.haveTail = 0;
}

func char hhh_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void hhh_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", hhh_board.haveHead, hhh_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            hhh_Field field = hhh_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, hhh_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, hhh_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = hhh_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 hhh_board_check_fault(int32 xx, int32 yy, int32 expect) {
    hhh_Field F = hhh_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 hhh_board_try_option(const hhh_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        hhh_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        hhh_Field F = hhh_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (hhh_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (hhh_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (hhh_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (hhh_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (hhh_board.haveHead) return 1;
            break;
        case TAIL:
            if (hhh_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void hhh_board_clearflags(int32 x, int32 y) {
    hhh_board.fields[x + y * 5].expected = 0;
}

func void hhh_board_setExpected(int32 x, int32 y, uint8 side) {
    hhh_board.fields[x + y * 5].expected = side;
}

func void hhh_board_add(const hhh_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        hhh_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        hhh_Field field = hhh_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        hhh_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            hhh_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            hhh_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            hhh_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            hhh_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            hhh_board.haveHead = 1;
            break;
        case TAIL:
            hhh_board.haveTail = 1;
            break;
        }
    }
}

func void hhh_board_rem(const hhh_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        hhh_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        hhh_Field field = hhh_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        hhh_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            hhh_board_clearflags(xx, yy+1);
            break;
        case EAST:
            hhh_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            hhh_board_clearflags(xx, yy-1);
            break;
        case WEST:
            hhh_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            hhh_board.haveHead = 0;
            break;
        case TAIL:
            hhh_board.haveTail = 0;
            break;
        }
    }
}

func void hhh_board_try_piece(uint8 p) {
    if (p == hhh_num_pieces) {
        hhh_found++;
        io.printf("Found solution %u\n", hhh_found);
        hhh_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            hhh_Field F = hhh_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<hhh_num_options; o++) {
                if (!hhh_board_try_option(&hhh_options[o][p], x, y)) {
                    hhh_board_add(&hhh_options[o][p], x, y, p);
                    hhh_board_try_piece(p+1);
                    hhh_board_rem(&hhh_options[o][p], x, y);
                }
                hhh_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE iii ------------------------------------------

type iii_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 iii_found;
uint64 iii_tried;

type iii_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type iii_Board struct {
    iii_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type iii_Piece struct {
    iii_Coor[4] side1;
    iii_Coor[4] side2;
}

type iii_Option struct {
    iii_Coor[4] parts;
}

iii_Board iii_board;

iii_Piece[] iii_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
iii_Option[iii_num_options][iii_num_pieces] iii_options;

const int32 iii_num_pieces = elemsof(iii_pieces);
const int32 iii_num_options = 8;


func iii_Coor iii_coor_rotate(iii_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    iii_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void iii_calculate_rotations() {
    memset(iii_options, 0, sizeof(iii_options));
    for (uint32 p=0; p<iii_num_pieces; p++) {
        const iii_Piece* P = &iii_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            iii_Option* O1 = &iii_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                iii_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = iii_coor_rotate(c, o);
            }
            iii_Option* O2 = &iii_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                iii_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = iii_coor_rotate(c, o);
            }
        }
    }
}

func void iii_board_set(int32 x, int32 y, iii_Field field) {
    iii_board.fields[x + y * 5] = field;
}

func iii_Field iii_board_get(int32 x, int32 y) {
    return iii_board.fields[x + y * 5];
}

func void iii_board_init() {
    iii_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            iii_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    iii_board_set(0, 4, f);
    iii_board.haveHead = 0;
    iii_board.haveTail = 0;
}

func char iii_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void iii_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", iii_board.haveHead, iii_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            iii_Field field = iii_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, iii_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, iii_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = iii_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 iii_board_check_fault(int32 xx, int32 yy, int32 expect) {
    iii_Field F = iii_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 iii_board_try_option(const iii_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        iii_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        iii_Field F = iii_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (iii_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (iii_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (iii_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (iii_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (iii_board.haveHead) return 1;
            break;
        case TAIL:
            if (iii_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void iii_board_clearflags(int32 x, int32 y) {
    iii_board.fields[x + y * 5].expected = 0;
}

func void iii_board_setExpected(int32 x, int32 y, uint8 side) {
    iii_board.fields[x + y * 5].expected = side;
}

func void iii_board_add(const iii_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        iii_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        iii_Field field = iii_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        iii_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            iii_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            iii_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            iii_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            iii_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            iii_board.haveHead = 1;
            break;
        case TAIL:
            iii_board.haveTail = 1;
            break;
        }
    }
}

func void iii_board_rem(const iii_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        iii_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        iii_Field field = iii_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        iii_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            iii_board_clearflags(xx, yy+1);
            break;
        case EAST:
            iii_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            iii_board_clearflags(xx, yy-1);
            break;
        case WEST:
            iii_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            iii_board.haveHead = 0;
            break;
        case TAIL:
            iii_board.haveTail = 0;
            break;
        }
    }
}

func void iii_board_try_piece(uint8 p) {
    if (p == iii_num_pieces) {
        iii_found++;
        io.printf("Found solution %u\n", iii_found);
        iii_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            iii_Field F = iii_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<iii_num_options; o++) {
                if (!iii_board_try_option(&iii_options[o][p], x, y)) {
                    iii_board_add(&iii_options[o][p], x, y, p);
                    iii_board_try_piece(p+1);
                    iii_board_rem(&iii_options[o][p], x, y);
                }
                iii_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE jjj ------------------------------------------

type jjj_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 jjj_found;
uint64 jjj_tried;

type jjj_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type jjj_Board struct {
    jjj_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type jjj_Piece struct {
    jjj_Coor[4] side1;
    jjj_Coor[4] side2;
}

type jjj_Option struct {
    jjj_Coor[4] parts;
}

jjj_Board jjj_board;

jjj_Piece[] jjj_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
jjj_Option[jjj_num_options][jjj_num_pieces] jjj_options;

const int32 jjj_num_pieces = elemsof(jjj_pieces);
const int32 jjj_num_options = 8;


func jjj_Coor jjj_coor_rotate(jjj_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    jjj_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void jjj_calculate_rotations() {
    memset(jjj_options, 0, sizeof(jjj_options));
    for (uint32 p=0; p<jjj_num_pieces; p++) {
        const jjj_Piece* P = &jjj_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            jjj_Option* O1 = &jjj_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                jjj_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = jjj_coor_rotate(c, o);
            }
            jjj_Option* O2 = &jjj_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                jjj_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = jjj_coor_rotate(c, o);
            }
        }
    }
}

func void jjj_board_set(int32 x, int32 y, jjj_Field field) {
    jjj_board.fields[x + y * 5] = field;
}

func jjj_Field jjj_board_get(int32 x, int32 y) {
    return jjj_board.fields[x + y * 5];
}

func void jjj_board_init() {
    jjj_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            jjj_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    jjj_board_set(0, 4, f);
    jjj_board.haveHead = 0;
    jjj_board.haveTail = 0;
}

func char jjj_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void jjj_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", jjj_board.haveHead, jjj_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            jjj_Field field = jjj_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, jjj_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, jjj_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = jjj_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 jjj_board_check_fault(int32 xx, int32 yy, int32 expect) {
    jjj_Field F = jjj_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 jjj_board_try_option(const jjj_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        jjj_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        jjj_Field F = jjj_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (jjj_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (jjj_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (jjj_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (jjj_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (jjj_board.haveHead) return 1;
            break;
        case TAIL:
            if (jjj_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void jjj_board_clearflags(int32 x, int32 y) {
    jjj_board.fields[x + y * 5].expected = 0;
}

func void jjj_board_setExpected(int32 x, int32 y, uint8 side) {
    jjj_board.fields[x + y * 5].expected = side;
}

func void jjj_board_add(const jjj_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        jjj_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        jjj_Field field = jjj_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        jjj_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            jjj_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            jjj_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            jjj_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            jjj_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            jjj_board.haveHead = 1;
            break;
        case TAIL:
            jjj_board.haveTail = 1;
            break;
        }
    }
}

func void jjj_board_rem(const jjj_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        jjj_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        jjj_Field field = jjj_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        jjj_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            jjj_board_clearflags(xx, yy+1);
            break;
        case EAST:
            jjj_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            jjj_board_clearflags(xx, yy-1);
            break;
        case WEST:
            jjj_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            jjj_board.haveHead = 0;
            break;
        case TAIL:
            jjj_board.haveTail = 0;
            break;
        }
    }
}

func void jjj_board_try_piece(uint8 p) {
    if (p == jjj_num_pieces) {
        jjj_found++;
        io.printf("Found solution %u\n", jjj_found);
        jjj_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            jjj_Field F = jjj_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<jjj_num_options; o++) {
                if (!jjj_board_try_option(&jjj_options[o][p], x, y)) {
                    jjj_board_add(&jjj_options[o][p], x, y, p);
                    jjj_board_try_piece(p+1);
                    jjj_board_rem(&jjj_options[o][p], x, y);
                }
                jjj_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE kkk ------------------------------------------

type kkk_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 kkk_found;
uint64 kkk_tried;

type kkk_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type kkk_Board struct {
    kkk_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type kkk_Piece struct {
    kkk_Coor[4] side1;
    kkk_Coor[4] side2;
}

type kkk_Option struct {
    kkk_Coor[4] parts;
}

kkk_Board kkk_board;

kkk_Piece[] kkk_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
kkk_Option[kkk_num_options][kkk_num_pieces] kkk_options;

const int32 kkk_num_pieces = elemsof(kkk_pieces);
const int32 kkk_num_options = 8;


func kkk_Coor kkk_coor_rotate(kkk_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    kkk_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void kkk_calculate_rotations() {
    memset(kkk_options, 0, sizeof(kkk_options));
    for (uint32 p=0; p<kkk_num_pieces; p++) {
        const kkk_Piece* P = &kkk_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            kkk_Option* O1 = &kkk_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                kkk_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = kkk_coor_rotate(c, o);
            }
            kkk_Option* O2 = &kkk_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                kkk_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = kkk_coor_rotate(c, o);
            }
        }
    }
}

func void kkk_board_set(int32 x, int32 y, kkk_Field field) {
    kkk_board.fields[x + y * 5] = field;
}

func kkk_Field kkk_board_get(int32 x, int32 y) {
    return kkk_board.fields[x + y * 5];
}

func void kkk_board_init() {
    kkk_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            kkk_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    kkk_board_set(0, 4, f);
    kkk_board.haveHead = 0;
    kkk_board.haveTail = 0;
}

func char kkk_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void kkk_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", kkk_board.haveHead, kkk_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            kkk_Field field = kkk_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, kkk_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, kkk_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = kkk_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 kkk_board_check_fault(int32 xx, int32 yy, int32 expect) {
    kkk_Field F = kkk_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 kkk_board_try_option(const kkk_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        kkk_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        kkk_Field F = kkk_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (kkk_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (kkk_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (kkk_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (kkk_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (kkk_board.haveHead) return 1;
            break;
        case TAIL:
            if (kkk_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void kkk_board_clearflags(int32 x, int32 y) {
    kkk_board.fields[x + y * 5].expected = 0;
}

func void kkk_board_setExpected(int32 x, int32 y, uint8 side) {
    kkk_board.fields[x + y * 5].expected = side;
}

func void kkk_board_add(const kkk_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        kkk_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        kkk_Field field = kkk_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        kkk_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            kkk_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            kkk_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            kkk_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            kkk_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            kkk_board.haveHead = 1;
            break;
        case TAIL:
            kkk_board.haveTail = 1;
            break;
        }
    }
}

func void kkk_board_rem(const kkk_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        kkk_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        kkk_Field field = kkk_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        kkk_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            kkk_board_clearflags(xx, yy+1);
            break;
        case EAST:
            kkk_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            kkk_board_clearflags(xx, yy-1);
            break;
        case WEST:
            kkk_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            kkk_board.haveHead = 0;
            break;
        case TAIL:
            kkk_board.haveTail = 0;
            break;
        }
    }
}

func void kkk_board_try_piece(uint8 p) {
    if (p == kkk_num_pieces) {
        kkk_found++;
        io.printf("Found solution %u\n", kkk_found);
        kkk_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            kkk_Field F = kkk_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<kkk_num_options; o++) {
                if (!kkk_board_try_option(&kkk_options[o][p], x, y)) {
                    kkk_board_add(&kkk_options[o][p], x, y, p);
                    kkk_board_try_piece(p+1);
                    kkk_board_rem(&kkk_options[o][p], x, y);
                }
                kkk_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE lll ------------------------------------------

type lll_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 lll_found;
uint64 lll_tried;

type lll_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type lll_Board struct {
    lll_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type lll_Piece struct {
    lll_Coor[4] side1;
    lll_Coor[4] side2;
}

type lll_Option struct {
    lll_Coor[4] parts;
}

lll_Board lll_board;

lll_Piece[] lll_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
lll_Option[lll_num_options][lll_num_pieces] lll_options;

const int32 lll_num_pieces = elemsof(lll_pieces);
const int32 lll_num_options = 8;


func lll_Coor lll_coor_rotate(lll_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    lll_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void lll_calculate_rotations() {
    memset(lll_options, 0, sizeof(lll_options));
    for (uint32 p=0; p<lll_num_pieces; p++) {
        const lll_Piece* P = &lll_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            lll_Option* O1 = &lll_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                lll_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = lll_coor_rotate(c, o);
            }
            lll_Option* O2 = &lll_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                lll_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = lll_coor_rotate(c, o);
            }
        }
    }
}

func void lll_board_set(int32 x, int32 y, lll_Field field) {
    lll_board.fields[x + y * 5] = field;
}

func lll_Field lll_board_get(int32 x, int32 y) {
    return lll_board.fields[x + y * 5];
}

func void lll_board_init() {
    lll_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            lll_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    lll_board_set(0, 4, f);
    lll_board.haveHead = 0;
    lll_board.haveTail = 0;
}

func char lll_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void lll_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", lll_board.haveHead, lll_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            lll_Field field = lll_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, lll_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, lll_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = lll_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 lll_board_check_fault(int32 xx, int32 yy, int32 expect) {
    lll_Field F = lll_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 lll_board_try_option(const lll_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        lll_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        lll_Field F = lll_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (lll_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (lll_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (lll_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (lll_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (lll_board.haveHead) return 1;
            break;
        case TAIL:
            if (lll_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void lll_board_clearflags(int32 x, int32 y) {
    lll_board.fields[x + y * 5].expected = 0;
}

func void lll_board_setExpected(int32 x, int32 y, uint8 side) {
    lll_board.fields[x + y * 5].expected = side;
}

func void lll_board_add(const lll_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        lll_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        lll_Field field = lll_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        lll_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            lll_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            lll_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            lll_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            lll_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            lll_board.haveHead = 1;
            break;
        case TAIL:
            lll_board.haveTail = 1;
            break;
        }
    }
}

func void lll_board_rem(const lll_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        lll_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        lll_Field field = lll_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        lll_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            lll_board_clearflags(xx, yy+1);
            break;
        case EAST:
            lll_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            lll_board_clearflags(xx, yy-1);
            break;
        case WEST:
            lll_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            lll_board.haveHead = 0;
            break;
        case TAIL:
            lll_board.haveTail = 0;
            break;
        }
    }
}

func void lll_board_try_piece(uint8 p) {
    if (p == lll_num_pieces) {
        lll_found++;
        io.printf("Found solution %u\n", lll_found);
        lll_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            lll_Field F = lll_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<lll_num_options; o++) {
                if (!lll_board_try_option(&lll_options[o][p], x, y)) {
                    lll_board_add(&lll_options[o][p], x, y, p);
                    lll_board_try_piece(p+1);
                    lll_board_rem(&lll_options[o][p], x, y);
                }
                lll_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE mmm ------------------------------------------

type mmm_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 mmm_found;
uint64 mmm_tried;

type mmm_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type mmm_Board struct {
    mmm_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type mmm_Piece struct {
    mmm_Coor[4] side1;
    mmm_Coor[4] side2;
}

type mmm_Option struct {
    mmm_Coor[4] parts;
}

mmm_Board mmm_board;

mmm_Piece[] mmm_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
mmm_Option[mmm_num_options][mmm_num_pieces] mmm_options;

const int32 mmm_num_pieces = elemsof(mmm_pieces);
const int32 mmm_num_options = 8;


func mmm_Coor mmm_coor_rotate(mmm_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    mmm_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void mmm_calculate_rotations() {
    memset(mmm_options, 0, sizeof(mmm_options));
    for (uint32 p=0; p<mmm_num_pieces; p++) {
        const mmm_Piece* P = &mmm_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            mmm_Option* O1 = &mmm_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                mmm_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = mmm_coor_rotate(c, o);
            }
            mmm_Option* O2 = &mmm_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                mmm_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = mmm_coor_rotate(c, o);
            }
        }
    }
}

func void mmm_board_set(int32 x, int32 y, mmm_Field field) {
    mmm_board.fields[x + y * 5] = field;
}

func mmm_Field mmm_board_get(int32 x, int32 y) {
    return mmm_board.fields[x + y * 5];
}

func void mmm_board_init() {
    mmm_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            mmm_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    mmm_board_set(0, 4, f);
    mmm_board.haveHead = 0;
    mmm_board.haveTail = 0;
}

func char mmm_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void mmm_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", mmm_board.haveHead, mmm_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            mmm_Field field = mmm_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, mmm_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, mmm_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = mmm_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 mmm_board_check_fault(int32 xx, int32 yy, int32 expect) {
    mmm_Field F = mmm_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 mmm_board_try_option(const mmm_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        mmm_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        mmm_Field F = mmm_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (mmm_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (mmm_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (mmm_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (mmm_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (mmm_board.haveHead) return 1;
            break;
        case TAIL:
            if (mmm_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void mmm_board_clearflags(int32 x, int32 y) {
    mmm_board.fields[x + y * 5].expected = 0;
}

func void mmm_board_setExpected(int32 x, int32 y, uint8 side) {
    mmm_board.fields[x + y * 5].expected = side;
}

func void mmm_board_add(const mmm_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        mmm_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        mmm_Field field = mmm_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        mmm_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            mmm_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            mmm_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            mmm_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            mmm_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            mmm_board.haveHead = 1;
            break;
        case TAIL:
            mmm_board.haveTail = 1;
            break;
        }
    }
}

func void mmm_board_rem(const mmm_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        mmm_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        mmm_Field field = mmm_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        mmm_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            mmm_board_clearflags(xx, yy+1);
            break;
        case EAST:
            mmm_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            mmm_board_clearflags(xx, yy-1);
            break;
        case WEST:
            mmm_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            mmm_board.haveHead = 0;
            break;
        case TAIL:
            mmm_board.haveTail = 0;
            break;
        }
    }
}

func void mmm_board_try_piece(uint8 p) {
    if (p == mmm_num_pieces) {
        mmm_found++;
        io.printf("Found solution %u\n", mmm_found);
        mmm_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            mmm_Field F = mmm_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<mmm_num_options; o++) {
                if (!mmm_board_try_option(&mmm_options[o][p], x, y)) {
                    mmm_board_add(&mmm_options[o][p], x, y, p);
                    mmm_board_try_piece(p+1);
                    mmm_board_rem(&mmm_options[o][p], x, y);
                }
                mmm_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE nnn ------------------------------------------

type nnn_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 nnn_found;
uint64 nnn_tried;

type nnn_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type nnn_Board struct {
    nnn_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type nnn_Piece struct {
    nnn_Coor[4] side1;
    nnn_Coor[4] side2;
}

type nnn_Option struct {
    nnn_Coor[4] parts;
}

nnn_Board nnn_board;

nnn_Piece[] nnn_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
nnn_Option[nnn_num_options][nnn_num_pieces] nnn_options;

const int32 nnn_num_pieces = elemsof(nnn_pieces);
const int32 nnn_num_options = 8;


func nnn_Coor nnn_coor_rotate(nnn_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    nnn_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void nnn_calculate_rotations() {
    memset(nnn_options, 0, sizeof(nnn_options));
    for (uint32 p=0; p<nnn_num_pieces; p++) {
        const nnn_Piece* P = &nnn_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            nnn_Option* O1 = &nnn_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                nnn_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = nnn_coor_rotate(c, o);
            }
            nnn_Option* O2 = &nnn_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                nnn_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = nnn_coor_rotate(c, o);
            }
        }
    }
}

func void nnn_board_set(int32 x, int32 y, nnn_Field field) {
    nnn_board.fields[x + y * 5] = field;
}

func nnn_Field nnn_board_get(int32 x, int32 y) {
    return nnn_board.fields[x + y * 5];
}

func void nnn_board_init() {
    nnn_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            nnn_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    nnn_board_set(0, 4, f);
    nnn_board.haveHead = 0;
    nnn_board.haveTail = 0;
}

func char nnn_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void nnn_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", nnn_board.haveHead, nnn_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            nnn_Field field = nnn_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, nnn_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, nnn_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = nnn_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 nnn_board_check_fault(int32 xx, int32 yy, int32 expect) {
    nnn_Field F = nnn_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 nnn_board_try_option(const nnn_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        nnn_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        nnn_Field F = nnn_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (nnn_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (nnn_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (nnn_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (nnn_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (nnn_board.haveHead) return 1;
            break;
        case TAIL:
            if (nnn_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void nnn_board_clearflags(int32 x, int32 y) {
    nnn_board.fields[x + y * 5].expected = 0;
}

func void nnn_board_setExpected(int32 x, int32 y, uint8 side) {
    nnn_board.fields[x + y * 5].expected = side;
}

func void nnn_board_add(const nnn_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        nnn_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        nnn_Field field = nnn_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        nnn_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            nnn_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            nnn_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            nnn_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            nnn_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            nnn_board.haveHead = 1;
            break;
        case TAIL:
            nnn_board.haveTail = 1;
            break;
        }
    }
}

func void nnn_board_rem(const nnn_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        nnn_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        nnn_Field field = nnn_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        nnn_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            nnn_board_clearflags(xx, yy+1);
            break;
        case EAST:
            nnn_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            nnn_board_clearflags(xx, yy-1);
            break;
        case WEST:
            nnn_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            nnn_board.haveHead = 0;
            break;
        case TAIL:
            nnn_board.haveTail = 0;
            break;
        }
    }
}

func void nnn_board_try_piece(uint8 p) {
    if (p == nnn_num_pieces) {
        nnn_found++;
        io.printf("Found solution %u\n", nnn_found);
        nnn_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            nnn_Field F = nnn_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<nnn_num_options; o++) {
                if (!nnn_board_try_option(&nnn_options[o][p], x, y)) {
                    nnn_board_add(&nnn_options[o][p], x, y, p);
                    nnn_board_try_piece(p+1);
                    nnn_board_rem(&nnn_options[o][p], x, y);
                }
                nnn_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ooo ------------------------------------------

type ooo_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 ooo_found;
uint64 ooo_tried;

type ooo_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type ooo_Board struct {
    ooo_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type ooo_Piece struct {
    ooo_Coor[4] side1;
    ooo_Coor[4] side2;
}

type ooo_Option struct {
    ooo_Coor[4] parts;
}

ooo_Board ooo_board;

ooo_Piece[] ooo_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
ooo_Option[ooo_num_options][ooo_num_pieces] ooo_options;

const int32 ooo_num_pieces = elemsof(ooo_pieces);
const int32 ooo_num_options = 8;


func ooo_Coor ooo_coor_rotate(ooo_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    ooo_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ooo_calculate_rotations() {
    memset(ooo_options, 0, sizeof(ooo_options));
    for (uint32 p=0; p<ooo_num_pieces; p++) {
        const ooo_Piece* P = &ooo_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            ooo_Option* O1 = &ooo_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                ooo_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = ooo_coor_rotate(c, o);
            }
            ooo_Option* O2 = &ooo_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                ooo_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = ooo_coor_rotate(c, o);
            }
        }
    }
}

func void ooo_board_set(int32 x, int32 y, ooo_Field field) {
    ooo_board.fields[x + y * 5] = field;
}

func ooo_Field ooo_board_get(int32 x, int32 y) {
    return ooo_board.fields[x + y * 5];
}

func void ooo_board_init() {
    ooo_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            ooo_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    ooo_board_set(0, 4, f);
    ooo_board.haveHead = 0;
    ooo_board.haveTail = 0;
}

func char ooo_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void ooo_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ooo_board.haveHead, ooo_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            ooo_Field field = ooo_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ooo_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ooo_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ooo_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 ooo_board_check_fault(int32 xx, int32 yy, int32 expect) {
    ooo_Field F = ooo_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 ooo_board_try_option(const ooo_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ooo_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        ooo_Field F = ooo_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (ooo_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (ooo_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (ooo_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (ooo_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (ooo_board.haveHead) return 1;
            break;
        case TAIL:
            if (ooo_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ooo_board_clearflags(int32 x, int32 y) {
    ooo_board.fields[x + y * 5].expected = 0;
}

func void ooo_board_setExpected(int32 x, int32 y, uint8 side) {
    ooo_board.fields[x + y * 5].expected = side;
}

func void ooo_board_add(const ooo_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        ooo_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ooo_Field field = ooo_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        ooo_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ooo_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            ooo_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            ooo_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            ooo_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            ooo_board.haveHead = 1;
            break;
        case TAIL:
            ooo_board.haveTail = 1;
            break;
        }
    }
}

func void ooo_board_rem(const ooo_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ooo_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ooo_Field field = ooo_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        ooo_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ooo_board_clearflags(xx, yy+1);
            break;
        case EAST:
            ooo_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            ooo_board_clearflags(xx, yy-1);
            break;
        case WEST:
            ooo_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            ooo_board.haveHead = 0;
            break;
        case TAIL:
            ooo_board.haveTail = 0;
            break;
        }
    }
}

func void ooo_board_try_piece(uint8 p) {
    if (p == ooo_num_pieces) {
        ooo_found++;
        io.printf("Found solution %u\n", ooo_found);
        ooo_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            ooo_Field F = ooo_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<ooo_num_options; o++) {
                if (!ooo_board_try_option(&ooo_options[o][p], x, y)) {
                    ooo_board_add(&ooo_options[o][p], x, y, p);
                    ooo_board_try_piece(p+1);
                    ooo_board_rem(&ooo_options[o][p], x, y);
                }
                ooo_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ppp ------------------------------------------

type ppp_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 ppp_found;
uint64 ppp_tried;

type ppp_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type ppp_Board struct {
    ppp_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type ppp_Piece struct {
    ppp_Coor[4] side1;
    ppp_Coor[4] side2;
}

type ppp_Option struct {
    ppp_Coor[4] parts;
}

ppp_Board ppp_board;

ppp_Piece[] ppp_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
ppp_Option[ppp_num_options][ppp_num_pieces] ppp_options;

const int32 ppp_num_pieces = elemsof(ppp_pieces);
const int32 ppp_num_options = 8;


func ppp_Coor ppp_coor_rotate(ppp_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    ppp_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ppp_calculate_rotations() {
    memset(ppp_options, 0, sizeof(ppp_options));
    for (uint32 p=0; p<ppp_num_pieces; p++) {
        const ppp_Piece* P = &ppp_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            ppp_Option* O1 = &ppp_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                ppp_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = ppp_coor_rotate(c, o);
            }
            ppp_Option* O2 = &ppp_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                ppp_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = ppp_coor_rotate(c, o);
            }
        }
    }
}

func void ppp_board_set(int32 x, int32 y, ppp_Field field) {
    ppp_board.fields[x + y * 5] = field;
}

func ppp_Field ppp_board_get(int32 x, int32 y) {
    return ppp_board.fields[x + y * 5];
}

func void ppp_board_init() {
    ppp_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            ppp_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    ppp_board_set(0, 4, f);
    ppp_board.haveHead = 0;
    ppp_board.haveTail = 0;
}

func char ppp_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void ppp_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ppp_board.haveHead, ppp_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            ppp_Field field = ppp_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ppp_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ppp_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ppp_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 ppp_board_check_fault(int32 xx, int32 yy, int32 expect) {
    ppp_Field F = ppp_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 ppp_board_try_option(const ppp_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ppp_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        ppp_Field F = ppp_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (ppp_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (ppp_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (ppp_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (ppp_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (ppp_board.haveHead) return 1;
            break;
        case TAIL:
            if (ppp_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ppp_board_clearflags(int32 x, int32 y) {
    ppp_board.fields[x + y * 5].expected = 0;
}

func void ppp_board_setExpected(int32 x, int32 y, uint8 side) {
    ppp_board.fields[x + y * 5].expected = side;
}

func void ppp_board_add(const ppp_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        ppp_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ppp_Field field = ppp_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        ppp_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ppp_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            ppp_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            ppp_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            ppp_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            ppp_board.haveHead = 1;
            break;
        case TAIL:
            ppp_board.haveTail = 1;
            break;
        }
    }
}

func void ppp_board_rem(const ppp_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ppp_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ppp_Field field = ppp_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        ppp_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ppp_board_clearflags(xx, yy+1);
            break;
        case EAST:
            ppp_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            ppp_board_clearflags(xx, yy-1);
            break;
        case WEST:
            ppp_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            ppp_board.haveHead = 0;
            break;
        case TAIL:
            ppp_board.haveTail = 0;
            break;
        }
    }
}

func void ppp_board_try_piece(uint8 p) {
    if (p == ppp_num_pieces) {
        ppp_found++;
        io.printf("Found solution %u\n", ppp_found);
        ppp_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            ppp_Field F = ppp_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<ppp_num_options; o++) {
                if (!ppp_board_try_option(&ppp_options[o][p], x, y)) {
                    ppp_board_add(&ppp_options[o][p], x, y, p);
                    ppp_board_try_piece(p+1);
                    ppp_board_rem(&ppp_options[o][p], x, y);
                }
                ppp_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE qqq ------------------------------------------

type qqq_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 qqq_found;
uint64 qqq_tried;

type qqq_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type qqq_Board struct {
    qqq_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type qqq_Piece struct {
    qqq_Coor[4] side1;
    qqq_Coor[4] side2;
}

type qqq_Option struct {
    qqq_Coor[4] parts;
}

qqq_Board qqq_board;

qqq_Piece[] qqq_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
qqq_Option[qqq_num_options][qqq_num_pieces] qqq_options;

const int32 qqq_num_pieces = elemsof(qqq_pieces);
const int32 qqq_num_options = 8;


func qqq_Coor qqq_coor_rotate(qqq_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    qqq_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void qqq_calculate_rotations() {
    memset(qqq_options, 0, sizeof(qqq_options));
    for (uint32 p=0; p<qqq_num_pieces; p++) {
        const qqq_Piece* P = &qqq_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            qqq_Option* O1 = &qqq_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                qqq_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = qqq_coor_rotate(c, o);
            }
            qqq_Option* O2 = &qqq_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                qqq_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = qqq_coor_rotate(c, o);
            }
        }
    }
}

func void qqq_board_set(int32 x, int32 y, qqq_Field field) {
    qqq_board.fields[x + y * 5] = field;
}

func qqq_Field qqq_board_get(int32 x, int32 y) {
    return qqq_board.fields[x + y * 5];
}

func void qqq_board_init() {
    qqq_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            qqq_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    qqq_board_set(0, 4, f);
    qqq_board.haveHead = 0;
    qqq_board.haveTail = 0;
}

func char qqq_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void qqq_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", qqq_board.haveHead, qqq_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            qqq_Field field = qqq_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, qqq_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, qqq_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = qqq_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 qqq_board_check_fault(int32 xx, int32 yy, int32 expect) {
    qqq_Field F = qqq_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 qqq_board_try_option(const qqq_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        qqq_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        qqq_Field F = qqq_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (qqq_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (qqq_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (qqq_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (qqq_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (qqq_board.haveHead) return 1;
            break;
        case TAIL:
            if (qqq_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void qqq_board_clearflags(int32 x, int32 y) {
    qqq_board.fields[x + y * 5].expected = 0;
}

func void qqq_board_setExpected(int32 x, int32 y, uint8 side) {
    qqq_board.fields[x + y * 5].expected = side;
}

func void qqq_board_add(const qqq_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        qqq_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        qqq_Field field = qqq_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        qqq_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            qqq_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            qqq_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            qqq_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            qqq_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            qqq_board.haveHead = 1;
            break;
        case TAIL:
            qqq_board.haveTail = 1;
            break;
        }
    }
}

func void qqq_board_rem(const qqq_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        qqq_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        qqq_Field field = qqq_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        qqq_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            qqq_board_clearflags(xx, yy+1);
            break;
        case EAST:
            qqq_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            qqq_board_clearflags(xx, yy-1);
            break;
        case WEST:
            qqq_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            qqq_board.haveHead = 0;
            break;
        case TAIL:
            qqq_board.haveTail = 0;
            break;
        }
    }
}

func void qqq_board_try_piece(uint8 p) {
    if (p == qqq_num_pieces) {
        qqq_found++;
        io.printf("Found solution %u\n", qqq_found);
        qqq_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            qqq_Field F = qqq_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<qqq_num_options; o++) {
                if (!qqq_board_try_option(&qqq_options[o][p], x, y)) {
                    qqq_board_add(&qqq_options[o][p], x, y, p);
                    qqq_board_try_piece(p+1);
                    qqq_board_rem(&qqq_options[o][p], x, y);
                }
                qqq_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE rrr ------------------------------------------

type rrr_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 rrr_found;
uint64 rrr_tried;

type rrr_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type rrr_Board struct {
    rrr_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type rrr_Piece struct {
    rrr_Coor[4] side1;
    rrr_Coor[4] side2;
}

type rrr_Option struct {
    rrr_Coor[4] parts;
}

rrr_Board rrr_board;

rrr_Piece[] rrr_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
rrr_Option[rrr_num_options][rrr_num_pieces] rrr_options;

const int32 rrr_num_pieces = elemsof(rrr_pieces);
const int32 rrr_num_options = 8;


func rrr_Coor rrr_coor_rotate(rrr_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    rrr_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void rrr_calculate_rotations() {
    memset(rrr_options, 0, sizeof(rrr_options));
    for (uint32 p=0; p<rrr_num_pieces; p++) {
        const rrr_Piece* P = &rrr_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            rrr_Option* O1 = &rrr_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                rrr_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = rrr_coor_rotate(c, o);
            }
            rrr_Option* O2 = &rrr_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                rrr_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = rrr_coor_rotate(c, o);
            }
        }
    }
}

func void rrr_board_set(int32 x, int32 y, rrr_Field field) {
    rrr_board.fields[x + y * 5] = field;
}

func rrr_Field rrr_board_get(int32 x, int32 y) {
    return rrr_board.fields[x + y * 5];
}

func void rrr_board_init() {
    rrr_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            rrr_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    rrr_board_set(0, 4, f);
    rrr_board.haveHead = 0;
    rrr_board.haveTail = 0;
}

func char rrr_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void rrr_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", rrr_board.haveHead, rrr_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            rrr_Field field = rrr_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, rrr_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, rrr_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = rrr_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 rrr_board_check_fault(int32 xx, int32 yy, int32 expect) {
    rrr_Field F = rrr_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 rrr_board_try_option(const rrr_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        rrr_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        rrr_Field F = rrr_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (rrr_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (rrr_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (rrr_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (rrr_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (rrr_board.haveHead) return 1;
            break;
        case TAIL:
            if (rrr_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void rrr_board_clearflags(int32 x, int32 y) {
    rrr_board.fields[x + y * 5].expected = 0;
}

func void rrr_board_setExpected(int32 x, int32 y, uint8 side) {
    rrr_board.fields[x + y * 5].expected = side;
}

func void rrr_board_add(const rrr_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        rrr_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        rrr_Field field = rrr_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        rrr_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            rrr_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            rrr_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            rrr_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            rrr_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            rrr_board.haveHead = 1;
            break;
        case TAIL:
            rrr_board.haveTail = 1;
            break;
        }
    }
}

func void rrr_board_rem(const rrr_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        rrr_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        rrr_Field field = rrr_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        rrr_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            rrr_board_clearflags(xx, yy+1);
            break;
        case EAST:
            rrr_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            rrr_board_clearflags(xx, yy-1);
            break;
        case WEST:
            rrr_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            rrr_board.haveHead = 0;
            break;
        case TAIL:
            rrr_board.haveTail = 0;
            break;
        }
    }
}

func void rrr_board_try_piece(uint8 p) {
    if (p == rrr_num_pieces) {
        rrr_found++;
        io.printf("Found solution %u\n", rrr_found);
        rrr_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            rrr_Field F = rrr_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<rrr_num_options; o++) {
                if (!rrr_board_try_option(&rrr_options[o][p], x, y)) {
                    rrr_board_add(&rrr_options[o][p], x, y, p);
                    rrr_board_try_piece(p+1);
                    rrr_board_rem(&rrr_options[o][p], x, y);
                }
                rrr_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE sss ------------------------------------------

type sss_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 sss_found;
uint64 sss_tried;

type sss_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type sss_Board struct {
    sss_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type sss_Piece struct {
    sss_Coor[4] side1;
    sss_Coor[4] side2;
}

type sss_Option struct {
    sss_Coor[4] parts;
}

sss_Board sss_board;

sss_Piece[] sss_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
sss_Option[sss_num_options][sss_num_pieces] sss_options;

const int32 sss_num_pieces = elemsof(sss_pieces);
const int32 sss_num_options = 8;


func sss_Coor sss_coor_rotate(sss_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    sss_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void sss_calculate_rotations() {
    memset(sss_options, 0, sizeof(sss_options));
    for (uint32 p=0; p<sss_num_pieces; p++) {
        const sss_Piece* P = &sss_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            sss_Option* O1 = &sss_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                sss_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = sss_coor_rotate(c, o);
            }
            sss_Option* O2 = &sss_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                sss_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = sss_coor_rotate(c, o);
            }
        }
    }
}

func void sss_board_set(int32 x, int32 y, sss_Field field) {
    sss_board.fields[x + y * 5] = field;
}

func sss_Field sss_board_get(int32 x, int32 y) {
    return sss_board.fields[x + y * 5];
}

func void sss_board_init() {
    sss_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            sss_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    sss_board_set(0, 4, f);
    sss_board.haveHead = 0;
    sss_board.haveTail = 0;
}

func char sss_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void sss_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", sss_board.haveHead, sss_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            sss_Field field = sss_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, sss_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, sss_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = sss_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 sss_board_check_fault(int32 xx, int32 yy, int32 expect) {
    sss_Field F = sss_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 sss_board_try_option(const sss_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        sss_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        sss_Field F = sss_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (sss_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (sss_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (sss_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (sss_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (sss_board.haveHead) return 1;
            break;
        case TAIL:
            if (sss_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void sss_board_clearflags(int32 x, int32 y) {
    sss_board.fields[x + y * 5].expected = 0;
}

func void sss_board_setExpected(int32 x, int32 y, uint8 side) {
    sss_board.fields[x + y * 5].expected = side;
}

func void sss_board_add(const sss_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        sss_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        sss_Field field = sss_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        sss_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            sss_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            sss_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            sss_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            sss_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            sss_board.haveHead = 1;
            break;
        case TAIL:
            sss_board.haveTail = 1;
            break;
        }
    }
}

func void sss_board_rem(const sss_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        sss_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        sss_Field field = sss_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        sss_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            sss_board_clearflags(xx, yy+1);
            break;
        case EAST:
            sss_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            sss_board_clearflags(xx, yy-1);
            break;
        case WEST:
            sss_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            sss_board.haveHead = 0;
            break;
        case TAIL:
            sss_board.haveTail = 0;
            break;
        }
    }
}

func void sss_board_try_piece(uint8 p) {
    if (p == sss_num_pieces) {
        sss_found++;
        io.printf("Found solution %u\n", sss_found);
        sss_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            sss_Field F = sss_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<sss_num_options; o++) {
                if (!sss_board_try_option(&sss_options[o][p], x, y)) {
                    sss_board_add(&sss_options[o][p], x, y, p);
                    sss_board_try_piece(p+1);
                    sss_board_rem(&sss_options[o][p], x, y);
                }
                sss_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE ttt ------------------------------------------

type ttt_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 ttt_found;
uint64 ttt_tried;

type ttt_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type ttt_Board struct {
    ttt_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type ttt_Piece struct {
    ttt_Coor[4] side1;
    ttt_Coor[4] side2;
}

type ttt_Option struct {
    ttt_Coor[4] parts;
}

ttt_Board ttt_board;

ttt_Piece[] ttt_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
ttt_Option[ttt_num_options][ttt_num_pieces] ttt_options;

const int32 ttt_num_pieces = elemsof(ttt_pieces);
const int32 ttt_num_options = 8;


func ttt_Coor ttt_coor_rotate(ttt_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    ttt_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void ttt_calculate_rotations() {
    memset(ttt_options, 0, sizeof(ttt_options));
    for (uint32 p=0; p<ttt_num_pieces; p++) {
        const ttt_Piece* P = &ttt_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            ttt_Option* O1 = &ttt_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                ttt_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = ttt_coor_rotate(c, o);
            }
            ttt_Option* O2 = &ttt_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                ttt_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = ttt_coor_rotate(c, o);
            }
        }
    }
}

func void ttt_board_set(int32 x, int32 y, ttt_Field field) {
    ttt_board.fields[x + y * 5] = field;
}

func ttt_Field ttt_board_get(int32 x, int32 y) {
    return ttt_board.fields[x + y * 5];
}

func void ttt_board_init() {
    ttt_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            ttt_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    ttt_board_set(0, 4, f);
    ttt_board.haveHead = 0;
    ttt_board.haveTail = 0;
}

func char ttt_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void ttt_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", ttt_board.haveHead, ttt_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            ttt_Field field = ttt_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ttt_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, ttt_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = ttt_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 ttt_board_check_fault(int32 xx, int32 yy, int32 expect) {
    ttt_Field F = ttt_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 ttt_board_try_option(const ttt_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ttt_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        ttt_Field F = ttt_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (ttt_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (ttt_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (ttt_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (ttt_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (ttt_board.haveHead) return 1;
            break;
        case TAIL:
            if (ttt_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void ttt_board_clearflags(int32 x, int32 y) {
    ttt_board.fields[x + y * 5].expected = 0;
}

func void ttt_board_setExpected(int32 x, int32 y, uint8 side) {
    ttt_board.fields[x + y * 5].expected = side;
}

func void ttt_board_add(const ttt_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        ttt_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ttt_Field field = ttt_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        ttt_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ttt_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            ttt_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            ttt_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            ttt_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            ttt_board.haveHead = 1;
            break;
        case TAIL:
            ttt_board.haveTail = 1;
            break;
        }
    }
}

func void ttt_board_rem(const ttt_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        ttt_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        ttt_Field field = ttt_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        ttt_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            ttt_board_clearflags(xx, yy+1);
            break;
        case EAST:
            ttt_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            ttt_board_clearflags(xx, yy-1);
            break;
        case WEST:
            ttt_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            ttt_board.haveHead = 0;
            break;
        case TAIL:
            ttt_board.haveTail = 0;
            break;
        }
    }
}

func void ttt_board_try_piece(uint8 p) {
    if (p == ttt_num_pieces) {
        ttt_found++;
        io.printf("Found solution %u\n", ttt_found);
        ttt_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            ttt_Field F = ttt_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<ttt_num_options; o++) {
                if (!ttt_board_try_option(&ttt_options[o][p], x, y)) {
                    ttt_board_add(&ttt_options[o][p], x, y, p);
                    ttt_board_try_piece(p+1);
                    ttt_board_rem(&ttt_options[o][p], x, y);
                }
                ttt_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE uuu ------------------------------------------

type uuu_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 uuu_found;
uint64 uuu_tried;

type uuu_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type uuu_Board struct {
    uuu_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type uuu_Piece struct {
    uuu_Coor[4] side1;
    uuu_Coor[4] side2;
}

type uuu_Option struct {
    uuu_Coor[4] parts;
}

uuu_Board uuu_board;

uuu_Piece[] uuu_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
uuu_Option[uuu_num_options][uuu_num_pieces] uuu_options;

const int32 uuu_num_pieces = elemsof(uuu_pieces);
const int32 uuu_num_options = 8;


func uuu_Coor uuu_coor_rotate(uuu_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    uuu_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void uuu_calculate_rotations() {
    memset(uuu_options, 0, sizeof(uuu_options));
    for (uint32 p=0; p<uuu_num_pieces; p++) {
        const uuu_Piece* P = &uuu_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            uuu_Option* O1 = &uuu_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                uuu_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = uuu_coor_rotate(c, o);
            }
            uuu_Option* O2 = &uuu_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                uuu_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = uuu_coor_rotate(c, o);
            }
        }
    }
}

func void uuu_board_set(int32 x, int32 y, uuu_Field field) {
    uuu_board.fields[x + y * 5] = field;
}

func uuu_Field uuu_board_get(int32 x, int32 y) {
    return uuu_board.fields[x + y * 5];
}

func void uuu_board_init() {
    uuu_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            uuu_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    uuu_board_set(0, 4, f);
    uuu_board.haveHead = 0;
    uuu_board.haveTail = 0;
}

func char uuu_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void uuu_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", uuu_board.haveHead, uuu_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            uuu_Field field = uuu_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, uuu_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, uuu_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = uuu_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 uuu_board_check_fault(int32 xx, int32 yy, int32 expect) {
    uuu_Field F = uuu_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 uuu_board_try_option(const uuu_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        uuu_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        uuu_Field F = uuu_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (uuu_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (uuu_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (uuu_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (uuu_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (uuu_board.haveHead) return 1;
            break;
        case TAIL:
            if (uuu_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void uuu_board_clearflags(int32 x, int32 y) {
    uuu_board.fields[x + y * 5].expected = 0;
}

func void uuu_board_setExpected(int32 x, int32 y, uint8 side) {
    uuu_board.fields[x + y * 5].expected = side;
}

func void uuu_board_add(const uuu_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        uuu_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        uuu_Field field = uuu_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        uuu_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            uuu_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            uuu_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            uuu_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            uuu_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            uuu_board.haveHead = 1;
            break;
        case TAIL:
            uuu_board.haveTail = 1;
            break;
        }
    }
}

func void uuu_board_rem(const uuu_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        uuu_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        uuu_Field field = uuu_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        uuu_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            uuu_board_clearflags(xx, yy+1);
            break;
        case EAST:
            uuu_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            uuu_board_clearflags(xx, yy-1);
            break;
        case WEST:
            uuu_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            uuu_board.haveHead = 0;
            break;
        case TAIL:
            uuu_board.haveTail = 0;
            break;
        }
    }
}

func void uuu_board_try_piece(uint8 p) {
    if (p == uuu_num_pieces) {
        uuu_found++;
        io.printf("Found solution %u\n", uuu_found);
        uuu_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            uuu_Field F = uuu_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<uuu_num_options; o++) {
                if (!uuu_board_try_option(&uuu_options[o][p], x, y)) {
                    uuu_board_add(&uuu_options[o][p], x, y, p);
                    uuu_board_try_piece(p+1);
                    uuu_board_rem(&uuu_options[o][p], x, y);
                }
                uuu_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE vvv ------------------------------------------

type vvv_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 vvv_found;
uint64 vvv_tried;

type vvv_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type vvv_Board struct {
    vvv_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type vvv_Piece struct {
    vvv_Coor[4] side1;
    vvv_Coor[4] side2;
}

type vvv_Option struct {
    vvv_Coor[4] parts;
}

vvv_Board vvv_board;

vvv_Piece[] vvv_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
vvv_Option[vvv_num_options][vvv_num_pieces] vvv_options;

const int32 vvv_num_pieces = elemsof(vvv_pieces);
const int32 vvv_num_options = 8;


func vvv_Coor vvv_coor_rotate(vvv_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    vvv_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void vvv_calculate_rotations() {
    memset(vvv_options, 0, sizeof(vvv_options));
    for (uint32 p=0; p<vvv_num_pieces; p++) {
        const vvv_Piece* P = &vvv_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            vvv_Option* O1 = &vvv_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                vvv_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = vvv_coor_rotate(c, o);
            }
            vvv_Option* O2 = &vvv_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                vvv_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = vvv_coor_rotate(c, o);
            }
        }
    }
}

func void vvv_board_set(int32 x, int32 y, vvv_Field field) {
    vvv_board.fields[x + y * 5] = field;
}

func vvv_Field vvv_board_get(int32 x, int32 y) {
    return vvv_board.fields[x + y * 5];
}

func void vvv_board_init() {
    vvv_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            vvv_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    vvv_board_set(0, 4, f);
    vvv_board.haveHead = 0;
    vvv_board.haveTail = 0;
}

func char vvv_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void vvv_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", vvv_board.haveHead, vvv_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            vvv_Field field = vvv_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, vvv_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, vvv_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = vvv_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 vvv_board_check_fault(int32 xx, int32 yy, int32 expect) {
    vvv_Field F = vvv_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 vvv_board_try_option(const vvv_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        vvv_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        vvv_Field F = vvv_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (vvv_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (vvv_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (vvv_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (vvv_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (vvv_board.haveHead) return 1;
            break;
        case TAIL:
            if (vvv_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void vvv_board_clearflags(int32 x, int32 y) {
    vvv_board.fields[x + y * 5].expected = 0;
}

func void vvv_board_setExpected(int32 x, int32 y, uint8 side) {
    vvv_board.fields[x + y * 5].expected = side;
}

func void vvv_board_add(const vvv_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        vvv_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        vvv_Field field = vvv_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        vvv_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            vvv_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            vvv_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            vvv_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            vvv_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            vvv_board.haveHead = 1;
            break;
        case TAIL:
            vvv_board.haveTail = 1;
            break;
        }
    }
}

func void vvv_board_rem(const vvv_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        vvv_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        vvv_Field field = vvv_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        vvv_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            vvv_board_clearflags(xx, yy+1);
            break;
        case EAST:
            vvv_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            vvv_board_clearflags(xx, yy-1);
            break;
        case WEST:
            vvv_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            vvv_board.haveHead = 0;
            break;
        case TAIL:
            vvv_board.haveTail = 0;
            break;
        }
    }
}

func void vvv_board_try_piece(uint8 p) {
    if (p == vvv_num_pieces) {
        vvv_found++;
        io.printf("Found solution %u\n", vvv_found);
        vvv_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            vvv_Field F = vvv_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<vvv_num_options; o++) {
                if (!vvv_board_try_option(&vvv_options[o][p], x, y)) {
                    vvv_board_add(&vvv_options[o][p], x, y, p);
                    vvv_board_try_piece(p+1);
                    vvv_board_rem(&vvv_options[o][p], x, y);
                }
                vvv_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE www ------------------------------------------

type www_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 www_found;
uint64 www_tried;

type www_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type www_Board struct {
    www_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type www_Piece struct {
    www_Coor[4] side1;
    www_Coor[4] side2;
}

type www_Option struct {
    www_Coor[4] parts;
}

www_Board www_board;

www_Piece[] www_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
www_Option[www_num_options][www_num_pieces] www_options;

const int32 www_num_pieces = elemsof(www_pieces);
const int32 www_num_options = 8;


func www_Coor www_coor_rotate(www_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    www_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void www_calculate_rotations() {
    memset(www_options, 0, sizeof(www_options));
    for (uint32 p=0; p<www_num_pieces; p++) {
        const www_Piece* P = &www_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            www_Option* O1 = &www_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                www_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = www_coor_rotate(c, o);
            }
            www_Option* O2 = &www_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                www_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = www_coor_rotate(c, o);
            }
        }
    }
}

func void www_board_set(int32 x, int32 y, www_Field field) {
    www_board.fields[x + y * 5] = field;
}

func www_Field www_board_get(int32 x, int32 y) {
    return www_board.fields[x + y * 5];
}

func void www_board_init() {
    www_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            www_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    www_board_set(0, 4, f);
    www_board.haveHead = 0;
    www_board.haveTail = 0;
}

func char www_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void www_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", www_board.haveHead, www_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            www_Field field = www_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, www_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, www_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = www_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 www_board_check_fault(int32 xx, int32 yy, int32 expect) {
    www_Field F = www_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 www_board_try_option(const www_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        www_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        www_Field F = www_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (www_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (www_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (www_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (www_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (www_board.haveHead) return 1;
            break;
        case TAIL:
            if (www_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void www_board_clearflags(int32 x, int32 y) {
    www_board.fields[x + y * 5].expected = 0;
}

func void www_board_setExpected(int32 x, int32 y, uint8 side) {
    www_board.fields[x + y * 5].expected = side;
}

func void www_board_add(const www_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        www_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        www_Field field = www_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        www_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            www_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            www_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            www_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            www_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            www_board.haveHead = 1;
            break;
        case TAIL:
            www_board.haveTail = 1;
            break;
        }
    }
}

func void www_board_rem(const www_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        www_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        www_Field field = www_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        www_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            www_board_clearflags(xx, yy+1);
            break;
        case EAST:
            www_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            www_board_clearflags(xx, yy-1);
            break;
        case WEST:
            www_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            www_board.haveHead = 0;
            break;
        case TAIL:
            www_board.haveTail = 0;
            break;
        }
    }
}

func void www_board_try_piece(uint8 p) {
    if (p == www_num_pieces) {
        www_found++;
        io.printf("Found solution %u\n", www_found);
        www_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            www_Field F = www_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<www_num_options; o++) {
                if (!www_board_try_option(&www_options[o][p], x, y)) {
                    www_board_add(&www_options[o][p], x, y, p);
                    www_board_try_piece(p+1);
                    www_board_rem(&www_options[o][p], x, y);
                }
                www_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE xxx ------------------------------------------

type xxx_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 xxx_found;
uint64 xxx_tried;

type xxx_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type xxx_Board struct {
    xxx_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type xxx_Piece struct {
    xxx_Coor[4] side1;
    xxx_Coor[4] side2;
}

type xxx_Option struct {
    xxx_Coor[4] parts;
}

xxx_Board xxx_board;

xxx_Piece[] xxx_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
xxx_Option[xxx_num_options][xxx_num_pieces] xxx_options;

const int32 xxx_num_pieces = elemsof(xxx_pieces);
const int32 xxx_num_options = 8;


func xxx_Coor xxx_coor_rotate(xxx_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    xxx_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void xxx_calculate_rotations() {
    memset(xxx_options, 0, sizeof(xxx_options));
    for (uint32 p=0; p<xxx_num_pieces; p++) {
        const xxx_Piece* P = &xxx_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            xxx_Option* O1 = &xxx_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                xxx_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = xxx_coor_rotate(c, o);
            }
            xxx_Option* O2 = &xxx_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                xxx_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = xxx_coor_rotate(c, o);
            }
        }
    }
}

func void xxx_board_set(int32 x, int32 y, xxx_Field field) {
    xxx_board.fields[x + y * 5] = field;
}

func xxx_Field xxx_board_get(int32 x, int32 y) {
    return xxx_board.fields[x + y * 5];
}

func void xxx_board_init() {
    xxx_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            xxx_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    xxx_board_set(0, 4, f);
    xxx_board.haveHead = 0;
    xxx_board.haveTail = 0;
}

func char xxx_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void xxx_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", xxx_board.haveHead, xxx_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            xxx_Field field = xxx_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, xxx_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, xxx_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = xxx_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 xxx_board_check_fault(int32 xx, int32 yy, int32 expect) {
    xxx_Field F = xxx_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 xxx_board_try_option(const xxx_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        xxx_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        xxx_Field F = xxx_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (xxx_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (xxx_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (xxx_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (xxx_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (xxx_board.haveHead) return 1;
            break;
        case TAIL:
            if (xxx_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void xxx_board_clearflags(int32 x, int32 y) {
    xxx_board.fields[x + y * 5].expected = 0;
}

func void xxx_board_setExpected(int32 x, int32 y, uint8 side) {
    xxx_board.fields[x + y * 5].expected = side;
}

func void xxx_board_add(const xxx_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        xxx_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        xxx_Field field = xxx_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        xxx_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            xxx_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            xxx_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            xxx_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            xxx_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            xxx_board.haveHead = 1;
            break;
        case TAIL:
            xxx_board.haveTail = 1;
            break;
        }
    }
}

func void xxx_board_rem(const xxx_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        xxx_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        xxx_Field field = xxx_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        xxx_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            xxx_board_clearflags(xx, yy+1);
            break;
        case EAST:
            xxx_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            xxx_board_clearflags(xx, yy-1);
            break;
        case WEST:
            xxx_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            xxx_board.haveHead = 0;
            break;
        case TAIL:
            xxx_board.haveTail = 0;
            break;
        }
    }
}

func void xxx_board_try_piece(uint8 p) {
    if (p == xxx_num_pieces) {
        xxx_found++;
        io.printf("Found solution %u\n", xxx_found);
        xxx_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            xxx_Field F = xxx_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<xxx_num_options; o++) {
                if (!xxx_board_try_option(&xxx_options[o][p], x, y)) {
                    xxx_board_add(&xxx_options[o][p], x, y, p);
                    xxx_board_try_piece(p+1);
                    xxx_board_rem(&xxx_options[o][p], x, y);
                }
                xxx_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE yyy ------------------------------------------

type yyy_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 yyy_found;
uint64 yyy_tried;

type yyy_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type yyy_Board struct {
    yyy_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type yyy_Piece struct {
    yyy_Coor[4] side1;
    yyy_Coor[4] side2;
}

type yyy_Option struct {
    yyy_Coor[4] parts;
}

yyy_Board yyy_board;

yyy_Piece[] yyy_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
yyy_Option[yyy_num_options][yyy_num_pieces] yyy_options;

const int32 yyy_num_pieces = elemsof(yyy_pieces);
const int32 yyy_num_options = 8;


func yyy_Coor yyy_coor_rotate(yyy_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    yyy_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void yyy_calculate_rotations() {
    memset(yyy_options, 0, sizeof(yyy_options));
    for (uint32 p=0; p<yyy_num_pieces; p++) {
        const yyy_Piece* P = &yyy_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            yyy_Option* O1 = &yyy_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                yyy_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = yyy_coor_rotate(c, o);
            }
            yyy_Option* O2 = &yyy_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                yyy_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = yyy_coor_rotate(c, o);
            }
        }
    }
}

func void yyy_board_set(int32 x, int32 y, yyy_Field field) {
    yyy_board.fields[x + y * 5] = field;
}

func yyy_Field yyy_board_get(int32 x, int32 y) {
    return yyy_board.fields[x + y * 5];
}

func void yyy_board_init() {
    yyy_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            yyy_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    yyy_board_set(0, 4, f);
    yyy_board.haveHead = 0;
    yyy_board.haveTail = 0;
}

func char yyy_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void yyy_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", yyy_board.haveHead, yyy_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            yyy_Field field = yyy_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, yyy_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, yyy_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = yyy_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 yyy_board_check_fault(int32 xx, int32 yy, int32 expect) {
    yyy_Field F = yyy_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 yyy_board_try_option(const yyy_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        yyy_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        yyy_Field F = yyy_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (yyy_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (yyy_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (yyy_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (yyy_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (yyy_board.haveHead) return 1;
            break;
        case TAIL:
            if (yyy_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void yyy_board_clearflags(int32 x, int32 y) {
    yyy_board.fields[x + y * 5].expected = 0;
}

func void yyy_board_setExpected(int32 x, int32 y, uint8 side) {
    yyy_board.fields[x + y * 5].expected = side;
}

func void yyy_board_add(const yyy_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        yyy_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        yyy_Field field = yyy_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        yyy_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            yyy_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            yyy_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            yyy_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            yyy_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            yyy_board.haveHead = 1;
            break;
        case TAIL:
            yyy_board.haveTail = 1;
            break;
        }
    }
}

func void yyy_board_rem(const yyy_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        yyy_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        yyy_Field field = yyy_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        yyy_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            yyy_board_clearflags(xx, yy+1);
            break;
        case EAST:
            yyy_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            yyy_board_clearflags(xx, yy-1);
            break;
        case WEST:
            yyy_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            yyy_board.haveHead = 0;
            break;
        case TAIL:
            yyy_board.haveTail = 0;
            break;
        }
    }
}

func void yyy_board_try_piece(uint8 p) {
    if (p == yyy_num_pieces) {
        yyy_found++;
        io.printf("Found solution %u\n", yyy_found);
        yyy_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            yyy_Field F = yyy_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<yyy_num_options; o++) {
                if (!yyy_board_try_option(&yyy_options[o][p], x, y)) {
                    yyy_board_add(&yyy_options[o][p], x, y, p);
                    yyy_board_try_piece(p+1);
                    yyy_board_rem(&yyy_options[o][p], x, y);
                }
                yyy_tried++;
                if (p==0) break;
            }
        }
    }
}

// ---- TEMPLATE zzz ------------------------------------------

type zzz_Coor struct {
    int8 x;
    int8 y;
    uint8 flags;
}

uint32 zzz_found;
uint64 zzz_tried;

type zzz_Field struct {
#if 0
    FieldStatus status : 2;
    uint32 piece_id : 4;
    uint32 flags : 3;
    uint32 expected : 3;  // set by other pieces
#endif
    FieldStatus status;
    uint8 piece_id;
    uint8 flags;
    uint8 expected;  // set by other pieces
}

type zzz_Board struct {
    zzz_Field[5*5] fields;
    bool haveHead;
    bool haveTail;
}

type zzz_Piece struct {
    zzz_Coor[4] side1;
    zzz_Coor[4] side2;
}

type zzz_Option struct {
    zzz_Coor[4] parts;
}

zzz_Board zzz_board;

zzz_Piece[] zzz_pieces = {
    { // Hollow piece
        .side1 = { { 0, 0, 0 } },
        .side2 = { { 0, 0, 0 } },
    },
    { // S-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1, NORTH }, { 1, 1, SOUTH }, { 1, 2, 0 } },
        .side2 = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 1, WEST }, { 2, 1, SOUTH } },
    },
    { // L-shaped
        .side1 = { { 0, 0, 0 }, { 0, 1 , 0 }, { 0, 2, NORTH }, { 1, 0, EAST } },
        .side2 = { { 0, 0, 0 }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, 0 } }
    },
    { // L-shaped, head
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 2, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, NORTH }, { 1, 0 , 0 }, { 1, 1, 0 }, { 1, 2, HEAD } }
    },
    { // 3 1-side empty
        .side1 = { { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0, 0 } },
        .side2 = { { 0, 0, 0 }, { 0, 1, EAST }, { 1, 0, EAST } },
    },
    { // 3 2-tails
        .side1 = { { 0, 0, WEST }, { 0, 1, TAIL }, { 1, 0, 0 } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 1, 0, TAIL } },
    },
    { // I-shaped, 3-straight
        .side1 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, HEAD } },
        .side2 = { { 0, 0, SOUTH }, { 0, 1, 0 }, { 0, 2, WEST } },
    },
    { // I-shaped, 2 long
        .side1 = { { 0, 0, WEST }, { 0, 1, NORTH } },
        .side2 = { { 0, 0, 0 }, { 0, 1, 0 } },
    },
}
zzz_Option[zzz_num_options][zzz_num_pieces] zzz_options;

const int32 zzz_num_pieces = elemsof(zzz_pieces);
const int32 zzz_num_options = 8;


func zzz_Coor zzz_coor_rotate(zzz_Coor input, uint32 rotation) {
    int8 x = input.x;
    int8 y = input.y;
    int8 t;
    switch (rotation) {
    case 0: // nothing to do
        break;
    case 1: // 90 degrees right
        t = x;
        x = y;
        y = -t;
        break;
    case 2: // 180 degrees right
        x = -x;
        y = -y;
        break;
    case 3: // 270 degrees right
        t = x;
        x = -y;
        y = t;
        break;
    }
    uint8 flags = input.flags;  // keep HEAD/TAIL, rotate NESW
    if (rotation > 0 && flags >= NORTH && flags <= WEST) {
        flags += rotation;
        if (flags > 4) flags -= 4;
    }

    zzz_Coor result = { x, y, flags }
    return result;
}

// calculate all rotations + flipped rotations
func void zzz_calculate_rotations() {
    memset(zzz_options, 0, sizeof(zzz_options));
    for (uint32 p=0; p<zzz_num_pieces; p++) {
        const zzz_Piece* P = &zzz_pieces[p];
        for (uint32 o=0; o<4; o++) {  // 4 rotations
            zzz_Option* O1 = &zzz_options[o][p];
            for (uint32 i=0; i<4; i++) {  // side1
                zzz_Coor c = P.side1[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O1.parts[i] = zzz_coor_rotate(c, o);
            }
            zzz_Option* O2 = &zzz_options[o+4][p];
            for (uint32 i=0; i<4; i++) {  // side2
                zzz_Coor c = P.side2[i];
                if (i != 0 && c.x == 0 && c.y == 0) break;
                O2.parts[i] = zzz_coor_rotate(c, o);
            }
        }
    }
}

func void zzz_board_set(int32 x, int32 y, zzz_Field field) {
    zzz_board.fields[x + y * 5] = field;
}

func zzz_Field zzz_board_get(int32 x, int32 y) {
    return zzz_board.fields[x + y * 5];
}

func void zzz_board_init() {
    zzz_Field f;
    f.status = FIELD_FREE;
    f.piece_id = 0;
    f.flags = 0;
    f.expected = 0;
    for (int32 y=0; y<5; y++) {
        for (int32 x=0; x<5; x++) {
            zzz_board_set(x, y, f);
        }
    }
    f.status = FIELD_BLOCKED;
    zzz_board_set(0, 4, f);
    zzz_board.haveHead = 0;
    zzz_board.haveTail = 0;
}

func char zzz_flags2char(int32 flags) {
    char f = ' ';
    switch (flags) {
    case NORTH:
        f = 'N';
        break;
    case EAST:
        f = 'E';
        break;
    case SOUTH:
        f = 'S';
        break;
    case WEST:
        f = 'W';
        break;
    case HEAD:
        f = 'H';
        break;
    case TAIL:
        f = 'T';
        break;
    }
    return f;
}

func void zzz_board_print() {
    char[1024] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += io.sprintf(cp, "Board: Head=%d  Tail=%d\n", zzz_board.haveHead, zzz_board.haveTail);
    for (int32 y=4; y>=0; y--) {
        cp += io.sprintf(cp, "---------------------\n");
        for (int32 x=0; x<5; x++) {
            *cp++ = '|';
            zzz_Field field = zzz_board.fields[x + y * 5];
            switch (field.status) {
            case FIELD_FREE:
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, zzz_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                *cp++ = ' ';
                *cp++ = ' ';
                break;
            case FIELD_BLOCKED:
                cp += io.sprintf(cp, ANSI_DARKGREY"XXX"ANSI_NORMAL);
                break;
            default:
            {
                int32 flags = field.flags;
                if (field.expected) {
                    cp += io.sprintf(cp, ANSI_RED"%c"ANSI_NORMAL, zzz_flags2char(field.expected));
                } else {
                    *cp++ = ' ';
                }
                cp += io.sprintf(cp, ANSI_GREEN"%c", '0' + field.piece_id);
                *cp++ = zzz_flags2char(flags);
                cp += io.sprintf(cp, ANSI_NORMAL);
                break;
            }
            }
        }
        *cp++ = '|';
        *cp++ = '\n';
    }
    cp += io.sprintf(cp, "---------------------\n");
    *cp = 0;
    io.puts(buffer);
}

func int32 zzz_board_check_fault(int32 xx, int32 yy, int32 expect) {
    zzz_Field F = zzz_board_get(xx, yy);
    switch (F.status) {
    case FIELD_FREE:
        if (F.expected && F.expected != expect) return 1;
        break;
    case FIELD_BLOCKED:
        return 1;
    case FIELD_TAKEN:
        if (F.flags != expect) return 1;
        break;
    }
    return 0;
}

// return 0=OK, 1=Not OK
func int32 zzz_board_try_option(const zzz_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        zzz_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) return 0;    // ignore unused parts
        int32 xx = x + c.x;
        if (xx < 0 || xx > 4) return 1;
        int32 yy = y + c.y;
        if (yy < 0 || yy > 4) return 1;
        zzz_Field F = zzz_board_get(xx, yy);
        if (F.status != FIELD_FREE) return 1;
        if (F.expected != 0 && F.expected != c.flags) return 1;
        switch (c.flags) {
        case NORTH:
            if (yy == 4) return 1;
            if (zzz_board_check_fault(xx, yy+1, SOUTH)) return 1;
            break;
        case EAST:
            if (xx == 4) return 1;
            if (zzz_board_check_fault(xx+1, yy, WEST)) return 1;
            break;
        case SOUTH:
            if (yy == 0) return 1;
            if (zzz_board_check_fault(xx, yy-1, NORTH)) return 1;
            break;
        case WEST:
            if (xx == 0) return 1;
            if (zzz_board_check_fault(xx-1, yy, EAST)) return 1;
            break;
        case HEAD:
            if (zzz_board.haveHead) return 1;
            break;
        case TAIL:
            if (zzz_board.haveTail) return 1;
            break;
        }
    }
    return 0;
}

func void zzz_board_clearflags(int32 x, int32 y) {
    zzz_board.fields[x + y * 5].expected = 0;
}

func void zzz_board_setExpected(int32 x, int32 y, uint8 side) {
    zzz_board.fields[x + y * 5].expected = side;
}

func void zzz_board_add(const zzz_Option* P, int32 x, int32 y, uint8 id) {
    for (uint32 i=0; i<4; i++) {
        zzz_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        zzz_Field field = zzz_board_get(xx, yy);
        //assert(field.status == FIELD_FREE);
        field.status = FIELD_TAKEN;
        field.piece_id = id;
        field.flags = c.flags;
        zzz_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            zzz_board_setExpected(xx, yy+1, SOUTH);
            break;
        case EAST:
            zzz_board_setExpected(xx+1, yy, WEST);
            break;
        case SOUTH:
            field.flags = NORTH;
            zzz_board_setExpected(xx, yy-1, NORTH);
            break;
        case WEST:
            zzz_board_setExpected(xx-1, yy, EAST);
            break;
        case HEAD:
            zzz_board.haveHead = 1;
            break;
        case TAIL:
            zzz_board.haveTail = 1;
            break;
        }
    }
}

func void zzz_board_rem(const zzz_Option* P, int32 x, int32 y) {
    for (uint32 i=0; i<4; i++) {
        zzz_Coor c = P.parts[i];
        if (i != 0 && c.x == 0 && c.y == 0) break;
        int32 xx = x + c.x;
        int32 yy = y + c.y;
        zzz_Field field = zzz_board_get(xx, yy);
        field.status = FIELD_FREE;
        field.piece_id = 0;
        field.flags = 0;
        zzz_board_set(xx, yy, field);
        switch (c.flags) {
        case NORTH:
            zzz_board_clearflags(xx, yy+1);
            break;
        case EAST:
            zzz_board_clearflags(xx+1, yy);
            break;
        case SOUTH:
            zzz_board_clearflags(xx, yy-1);
            break;
        case WEST:
            zzz_board_clearflags(xx-1, yy);
            break;
        case HEAD:
            zzz_board.haveHead = 0;
            break;
        case TAIL:
            zzz_board.haveTail = 0;
            break;
        }
    }
}

func void zzz_board_try_piece(uint8 p) {
    if (p == zzz_num_pieces) {
        zzz_found++;
        io.printf("Found solution %u\n", zzz_found);
        zzz_board_print();
        return;
    }
    for (int32 y=4; y>=0; y--) {
        for (int32 x=0; x<5; x++) {
            zzz_Field F = zzz_board_get(x, y);
            if (F.status != FIELD_FREE) continue;
            for (uint32 o=0; o<zzz_num_options; o++) {
                if (!zzz_board_try_option(&zzz_options[o][p], x, y)) {
                    zzz_board_add(&zzz_options[o][p], x, y, p);
                    zzz_board_try_piece(p+1);
                    zzz_board_rem(&zzz_options[o][p], x, y);
                }
                zzz_tried++;
                if (p==0) break;
            }
        }
    }
}

