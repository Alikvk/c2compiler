/* Copyright 2013-2015 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <vector>
#include <set>
#include <assert.h>
#include <inttypes.h>

#include <llvm/ADT/SmallString.h>
#include <llvm/Support/FileSystem.h>
// for tool_output_file
//#include <llvm/Support/ToolOutputFile.h>

#include "CodeGen/InterfaceGenerator.h"
#include "CGenerator/HeaderNamer.h"
#include "AST/Module.h"
#include "AST/AST.h"
#include "AST/Attr.h"
#include "AST/Stmt.h"
#include "AST/Type.h"
#include "AST/Decl.h"
#include "AST/Expr.h"
#include "FileUtils/FileUtils.h"
#include "Utils/StringBuilder.h"
#include "Utils/UtilsConstants.h"
#include "Utils/GenUtils.h"
#include "Utils/Utils.h"

//#define CCODE_DEBUG
#ifdef CCODE_DEBUG
#include "Utils/color.h"
#include <iostream>
#define LOG_FUNC std::cerr << ANSI_BLUE << __func__ << "()" << ANSI_NORMAL << "\n";
#define LOG_DECL(_d) std::cerr << ANSI_BLUE << __func__ << "() " << ANSI_YELLOW  << _d->getName()<< ANSI_NORMAL << "\n";
#else
#define LOG_FUNC
#define LOG_DECL(_d)
#endif

using namespace C2;
using namespace llvm;
using namespace clang;

InterfaceGenerator::InterfaceGenerator(const std::string& moduleName_)
    : moduleName(moduleName_)
{
}

void InterfaceGenerator::write(const std::string& outputDir, bool printCode) {
    iface << "// WARNING: this file is auto-generated by the C2 compiler.\n";
    iface << "// Any changes you make might be lost!`\n\n";

    iface << "module " << moduleName << ";\n";
    iface << '\n';

    // ImportDecls
    for (EntriesIter iter = entries.begin(); iter != entries.end(); ++iter) {
        const AST* ast = *iter;
        for (unsigned i=0; i<ast->numImports(); i++) {
            EmitImport(ast->getImport(i));
        }
    }
    iface << '\n';

    // TypeDecls
    for (EntriesIter iter = entries.begin(); iter != entries.end(); ++iter) {
        const AST* ast = *iter;
        for (unsigned i=0; i<ast->numTypes(); i++) {
            EmitTypeDecl(ast->getType(i));
            iface << '\n';
        }
    }

    // VarDecls
    for (EntriesIter iter = entries.begin(); iter != entries.end(); ++iter) {
        const AST* ast = *iter;
        for (unsigned i=0; i<ast->numVars(); i++) {
            EmitVarDecl(ast->getVar(i), 0);
            iface << ";\n\n";
        }
    }

    // FunctionDecls
    for (EntriesIter iter = entries.begin(); iter != entries.end(); ++iter) {
        const AST* ast = *iter;
        for (unsigned i=0; i<ast->numFunctions(); i++) {
            EmitFunctionDecl(ast->getFunction(i));
        }
    }

    // ArrayValueDecls
    // TODO
    //unsigned numArrayValues() const { return arrayValues.size(); }
    //ArrayValueDecl* getArrayValue(unsigned i) const { return arrayValues[i]; }

    // write file
    // TODO handle errors
    std::string filename = moduleName + ".c2i";
    FileUtils::writeFile(outputDir.c_str(), outputDir + filename, iface);

    if (printCode) {
        printf("---- code for %s ----\n%s\n", filename.c_str(), (const char*)iface);
    }
}

void InterfaceGenerator::EmitExpr(const Expr* E, StringBuilder& output) {
    LOG_FUNC
    switch (E->getKind()) {
    case EXPR_INTEGER_LITERAL:
        {
            const IntegerLiteral* N = cast<IntegerLiteral>(E);
            output.radix(N->getRadix(), N->Value.getSExtValue());
            return;
        }
    case EXPR_FLOAT_LITERAL:
        {
            const FloatingLiteral* F = cast<FloatingLiteral>(E);
            char temp[20];
            sprintf(temp, "%f", F->Value.convertToFloat());
            output << temp;
            return;
        }
    case EXPR_BOOL_LITERAL:
        {
            const BooleanLiteral* B = cast<BooleanLiteral>(E);
            iface << (int)B->getValue();
            return;
        }
    case EXPR_CHAR_LITERAL:
        {
            const CharacterLiteral* C = cast<CharacterLiteral>(E);
            C->printLiteral(output);
            return;
        }
    case EXPR_STRING_LITERAL:
        {
            const StringLiteral* S = cast<StringLiteral>(E);
            EmitStringLiteral(S->value, output);
            return;
        }
    case EXPR_NIL:
        output << "NULL";
        return;
    case EXPR_CALL:
        EmitCallExpr(E, output);
        return;
    case EXPR_IDENTIFIER:
        EmitIdentifierExpr(E, output);
        return;
    case EXPR_INITLIST:
        {
            const InitListExpr* I = cast<InitListExpr>(E);
            output << "{ ";
            const ExprList& values = I->getValues();
            for (unsigned i=0; i<values.size(); i++) {
                if (i == 0 && values[0]->getKind() == EXPR_INITLIST) output << '\n';
                EmitExpr(values[i], output);
                if (i != values.size() -1) output << ", ";
                if (values[i]->getKind() == EXPR_INITLIST) output << '\n';
            }
            output << " }";
            return;
        }
    case EXPR_DESIGNATOR_INIT:
        {
            const DesignatedInitExpr* D = cast<DesignatedInitExpr>(E);
            if (D->getDesignatorKind() == DesignatedInitExpr::ARRAY_DESIGNATOR) {
                output << '[';
                EmitExpr(D->getDesignator(), output);
                output << "] = ";
            } else {
                output << '.' << D->getField() << " = ";
            }
            EmitExpr(D->getInitValue(), output);
            return;
        }
    case EXPR_TYPE:
        {
            //const TypeExpr* T = cast<TypeExpr>(E);
            //EmitTypePreName(T->getType(), output);
            //EmitTypePostName(T->getType(), output);
            return;
        }
    case EXPR_BINOP:
        EmitBinaryOperator(E, output);
        return;
    case EXPR_CONDOP:
        EmitConditionalOperator(E, output);
        return;
    case EXPR_UNARYOP:
        EmitUnaryOperator(E, output);
        return;
    case EXPR_BUILTIN:
        {
            const BuiltinExpr* S = cast<BuiltinExpr>(E);
            if (S->isSizeof()) {
                output << "sizeof(";
                EmitExpr(S->getExpr(), output);
                output << ')';
            } else {
                const IdentifierExpr* I = cast<IdentifierExpr>(S->getExpr());
                Decl* D = I->getDecl();
                // should be VarDecl(for array/enum) or TypeDecl(array/enum)
                switch (D->getKind()) {
                case DECL_FUNC:
                    assert(0);
                    break;
                case DECL_VAR:
                    {
                        VarDecl* VD = cast<VarDecl>(D);
                        QualType Q = VD->getType();
                        if (Q.isArrayType()) {
                            // generate: (sizeof(array) / sizeof(array[0]))
                            output << "(sizeof(";
                            //EmitDecl(D, output);
                            output << ")/sizeof(";
                            //EmitDecl(D, output);
                            output << "[0]))";
                            return;
                        }
                        // TODO also allow elemsof for EnumType
                        // NOTE cannot be converted to C if used with enums
                        assert(0 && "TODO");
                        return;
                    }
                case DECL_ENUMVALUE:
                    break;
                case DECL_ALIASTYPE:
                case DECL_STRUCTTYPE:
                case DECL_ENUMTYPE:
                case DECL_FUNCTIONTYPE:
                case DECL_ARRAYVALUE:
                case DECL_IMPORT:
                case DECL_LABEL:
                    assert(0);
                    break;
                }
            }
            return;
        }
    case EXPR_ARRAYSUBSCRIPT:
        {
            const ArraySubscriptExpr* A = cast<ArraySubscriptExpr>(E);
            if (isa<BitOffsetExpr>(A->getIndex())) {
                EmitBitOffsetExpr(A->getBase(), A->getIndex(), output);
            } else {
                EmitExpr(A->getBase(), output);
                output << '[';
                EmitExpr(A->getIndex(), output);
                output << ']';
            }
            return;
        }
    case EXPR_MEMBER:
        EmitMemberExpr(E, output);
        return;
    case EXPR_PAREN:
        {
            const ParenExpr* P = cast<ParenExpr>(E);
            iface << '(';
            EmitExpr(P->getExpr(), iface);
            iface << ')';
            return;
        }
    case EXPR_BITOFFSET:
        assert(0 && "should not happen");
        break;
    case EXPR_CAST:
        {
            const ExplicitCastExpr* ECE = cast<ExplicitCastExpr>(E);
            iface << '(';
            //EmitTypePreName(ECE->getDestType(), iface);
            //EmitTypePostName(ECE->getDestType(), iface);
            iface << ")(";
            EmitExpr(ECE->getInner(), iface);
            iface << ')';
            return;
        }
    }
}

void InterfaceGenerator::EmitBinaryOperator(const Expr* E, StringBuilder& output) {
    LOG_FUNC
    const BinaryOperator* B = cast<BinaryOperator>(E);
    EmitExpr(B->getLHS(), output);
    output << ' ' << BinaryOperator::OpCode2str(B->getOpcode()) << ' ';
    EmitExpr(B->getRHS(), output);
}

void InterfaceGenerator::EmitConditionalOperator(const Expr* E, StringBuilder& output) {
    LOG_FUNC
    const ConditionalOperator* C = cast<ConditionalOperator>(E);
    EmitExpr(C->getCond(), output);
    output << " ? ";
    EmitExpr(C->getLHS(), output);
    output << " : ";
    EmitExpr(C->getRHS(), output);

}

void InterfaceGenerator::EmitUnaryOperator(const Expr* E, StringBuilder& output) {
    LOG_FUNC
    const UnaryOperator* U = cast<UnaryOperator>(E);

    switch (U->getOpcode()) {
    case UO_PostInc:
    case UO_PostDec:
        EmitExpr(U->getExpr(), output);
        output << UnaryOperator::OpCode2str(U->getOpcode());
        break;
    case UO_PreInc:
    case UO_PreDec:
    case UO_AddrOf:
    case UO_Deref:
    case UO_Plus:
    case UO_Minus:
    case UO_Not:
    case UO_LNot:
        //output.indent(indent);
        output << UnaryOperator::OpCode2str(U->getOpcode());
        EmitExpr(U->getExpr(), output);
        break;
    default:
        assert(0);
    }
}

void InterfaceGenerator::EmitMemberExpr(const Expr* E, StringBuilder& output) {
    LOG_FUNC
    const MemberExpr* M = cast<MemberExpr>(E);
    const IdentifierExpr* rhs = M->getMember();
    if (M->isModulePrefix()) {
        // A.B where A is a module
        //EmitDecl(M->getDecl(), output);
    } else {
        // A.B where A is decl of struct/union type
        EmitExpr(M->getBase(), iface);
        QualType LType = M->getBase()->getType();
        if (LType.isPointerType()) iface << "->";
        else iface << '.';
        iface << rhs->getName();
    }
}

void InterfaceGenerator::EmitCallExpr(const Expr* E, StringBuilder& output) {
    LOG_FUNC
    const CallExpr* C = cast<CallExpr>(E);
    EmitExpr(C->getFn(), output);
    output << '(';
    for (unsigned i=0; i<C->numArgs(); i++) {
        if (i != 0) output << ", ";
        EmitExpr(C->getArg(i), output);
    }
    const FunctionType* FT = cast<FunctionType>(C->getFn()->getType());
    const FunctionDecl* func = FT->getDecl();
    // generate default arguments in call
    if (C->numArgs() < func->numArgs()) {
        for (unsigned i=C->numArgs(); i<func->numArgs(); i++) {
            if (i != 0) output << ", ";
            VarDecl* arg = func->getArg(i);
            assert(arg->getInitValue());
            EmitExpr(arg->getInitValue(), output);
        }

    }
    output << ')';
}

void InterfaceGenerator::EmitIdentifierExpr(const Expr* E, StringBuilder& output) {
    LOG_FUNC
    //const IdentifierExpr* I = cast<IdentifierExpr>(E);
    //EmitDecl(I->getDecl(), output);
}

static void bitmask(unsigned width, StringBuilder& output) {
    char tmp[20];
    sprintf(tmp, "0x%" PRIX64"", Utils::bitmask(width));
    output << tmp;
}

void InterfaceGenerator::EmitBitOffsetExpr(const Expr* Base, Expr* E, StringBuilder& output) {
    LOG_FUNC
    // NOTE: only support RHS for now!
    // a[7:4] -> ((a >> 4) & 0xF);
    const BitOffsetExpr* B = cast<BitOffsetExpr>(E);
    assert(B->getLHS()->isConstant() && "only support constant bitoffset for now");
    assert(B->getRHS()->isConstant() && "only support constant bitoffset for now");
    assert(B->getWidth() != 0);
    output << "((";
    EmitExpr(Base, output);
    output << " >> ";
    EmitExpr(B->getRHS(), output);
    output << ") & ";
    bitmask(B->getWidth(), output);
    output << ')';
}

void InterfaceGenerator::EmitImport(const ImportDecl* D) {
    LOG_DECL(D)

    if (D->getModuleName() == moduleName) return; // skip 'self-import'

    iface << "import " << D->getModuleName();
    if (D->hasAlias()) iface << " as " << D->getName();
    if (D->isLocal()) iface << " local";
    iface << ";\n";
}

void InterfaceGenerator::EmitFunctionArgs(const FunctionDecl* F) {
    LOG_DECL(F)
    iface << '(';
    int count = F->numArgs();
    if (F->isVariadic()) count++;
    for (unsigned i=0; i<F->numArgs(); i++) {
        VarDecl* A = F->getArg(i);
        EmitArgVarDecl(A, i);
        if (count != 1) iface << ", ";
        count--;
    }
    if (F->isVariadic()) iface << "...";
    iface << ')';
}

void InterfaceGenerator::EmitTypeDecl(const TypeDecl* T) {
    LOG_DECL(T)

    switch (T->getKind()) {
    case DECL_FUNC:
    case DECL_VAR:
    case DECL_ENUMVALUE:
        assert(0);
        break;
    case DECL_ALIASTYPE:
        EmitAliasType(T);
        break;
    case DECL_STRUCTTYPE:
        EmitStructType(cast<StructTypeDecl>(T), 0);
        return;
    case DECL_ENUMTYPE:
        EmitEnumType(cast<EnumTypeDecl>(T));
        return;
    case DECL_FUNCTIONTYPE:
        EmitFunctionType(cast<FunctionTypeDecl>(T));
        return;
    case DECL_ARRAYVALUE:
    case DECL_IMPORT:
    case DECL_LABEL:
        assert(0);
        break;
    }
}

void InterfaceGenerator::EmitAliasType(const TypeDecl* T) {
    LOG_DECL(T);
    iface << "public type " << T->getName() << ' ';
    EmitType(T->getType());
    iface << ";\n";
}

void InterfaceGenerator::EmitStructType(const StructTypeDecl* S, unsigned indent) {
    LOG_DECL(S)
    if (S->isGlobal()) {
        iface << "public type " << S->getName() << ' ';
        iface << (S->isStruct() ? "struct" : "union");
    } else {
        iface.indent(indent);
        iface << (S->isStruct() ? "struct" : "union");
        iface << ' ' << S->getName();
    }
    iface << " {\n";
    for (unsigned i=0;i<S->numMembers(); i++) {
        Decl* member = S->getMember(i);
        if (isa<VarDecl>(member)) {
            EmitVarDecl(cast<VarDecl>(member), indent + INDENT);
            iface << ";\n";
        } else if (isa<StructTypeDecl>(member)) {
            EmitStructType(cast<StructTypeDecl>(member), indent+INDENT);
        } else {
            assert(0);
        }
    }
    iface.indent(indent);
    iface << '}';
    if (S->getName() != "" && !S->isGlobal()) {
        iface << ' ';
        //EmitDecl(S, iface);
    }
    EmitAttributes(S);
    iface << '\n';
}

void InterfaceGenerator::EmitEnumType(const EnumTypeDecl* E) {
    LOG_DECL(E)
    iface << "public type " << E->getName() << " enum ";
    EmitType(E->getImplType());
    iface << " {\n";
    for (unsigned i=0; i<E->numConstants(); i++) {
        EnumConstantDecl* C = E->getConstant(i);
        iface.indent(INDENT);
        iface << C->getName();
        if (C->getInitValue()) {
            iface << " = ";
            EmitExpr(C->getInitValue(), iface);
        }
        iface << ",\n";
    }
    iface << "}";
    EmitAttributes(E);
    iface << '\n';
}

// output: typedef void (*name)(args);
void InterfaceGenerator::EmitFunctionType(const FunctionTypeDecl* FTD) {
    LOG_DECL(FTD)
    iface << "public type " << FTD->getName() << " func ";
    FunctionDecl* F = FTD->getDecl();
    EmitType(F->getReturnType());
    EmitFunctionArgs(F);
    EmitAttributes(FTD);
    iface << ";\n";
}

void InterfaceGenerator::EmitType(QualType type) {
    LOG_FUNC
    if (type.isConstQualified()) iface << "const ";

    const Type* T = type.getTypePtr();
    switch (T->getTypeClass()) {
    case TC_BUILTIN:
        {
            // TODO handle Qualifiers
            const BuiltinType* BI = cast<BuiltinType>(T);
            iface << BuiltinType::kind2name(BI->getKind());
            break;
        }
    case TC_POINTER:
        // TODO handle Qualifiers
        EmitType(cast<PointerType>(T)->getPointeeType());
        iface << '*';
        break;
    case TC_ARRAY:
        {
            // TODO handle Qualifiers
            EmitType(cast<ArrayType>(T)->getElementType());

            // TEMP, use canonical type, since type can be AliasType
            type = type.getCanonicalType();
            const ArrayType* A = cast<ArrayType>(type);
            iface << '[';
            if (A->getSizeExpr()) {
                EmitExpr(A->getSizeExpr(), iface);
            }
            iface << ']';
            break;
        }
    case TC_UNRESOLVED:
        // TODO handle Qualifiers?
        {
            assert(0 && "should be resolved");
            //const UnresolvedType* U = cast<UnresolvedType>(T);
            //U->printLiteral(iface);
        }
        break;
    case TC_ALIAS:
        assert(0 && "TODO");
        //EmitTypePreName(cast<AliasType>(T)->getRefType(), iface);
        break;
    case TC_STRUCT:
        iface << cast<StructType>(T)->getDecl()->getName();
        break;
    case TC_ENUM:
        iface << cast<EnumType>(T)->getDecl()->getName();
        break;
    case TC_FUNCTION:
        assert(0 && "TODO");
        //EmitDecl(cast<FunctionType>(T)->getDecl(), iface);
        break;
    case TC_PACKAGE:
        assert(0 && "TODO");
        break;
    }
}

void InterfaceGenerator::EmitArgVarDecl(const VarDecl* D, unsigned index) {
    LOG_DECL(D)
    EmitType(D->getType());
    iface << ' '<< D->getName();
    // TODO generate default arg values?
}

void InterfaceGenerator::EmitFunctionDecl(const FunctionDecl* F) {
    LOG_DECL(F)
    // TODO
    iface << "public func ";
    EmitType(F->getReturnType());
    iface << ' ' << F->getName();
    EmitFunctionArgs(F);
    EmitAttributes(F);
    iface << ";\n";
}

void InterfaceGenerator::EmitVarDecl(const VarDecl* D, unsigned indent) {
    LOG_DECL(D)
    iface.indent(indent);
    EmitType(D->getType());
    iface << ' ' << D->getName();
    // TODO when initval (if constant?)
    if (D->getInitValue()) {
       // iface << " = ";
        //EmitExpr(D->getInitValue(), iface);
    }
}

void InterfaceGenerator::EmitStringLiteral(const std::string& input, StringBuilder& output) {
    LOG_FUNC
    // always cast to 'unsigned char*'
    output << '"';
    const char* cp = input.c_str();
    for (unsigned i=0; i<input.size(); i++) {
        switch (*cp) {
        case '\n':
            output << "\\n";
            break;
        case '\r':
            output << "\\r";
            break;
        case '\t':
            output << "\\t";
            break;
        case '\033':
            output << "\\033";
            break;
        // TODO other escaped chars
        default:
            output << *cp;
            break;
        }
        cp++;
    }
    output << '"';
}

void InterfaceGenerator::EmitAttributes(const Decl* D) {
    if (!D->hasAttributes()) return;

    bool first = true;
    const AttrList& AL = D->getAttributes();
    for (AttrListConstIter iter = AL.begin(); iter != AL.end(); ++iter) {
        const Attr* A = *iter;
        const Expr* Arg = A->getArg();
        switch (A->getKind()) {
        case ATTR_UNKNOWN:
        case ATTR_EXPORT:
        case ATTR_NORETURN:
        case ATTR_INLINE:
        case ATTR_UNUSED_PARAMS:
            // ignore for now
            break;
        case ATTR_WEAK:
        case ATTR_PACKED:
        case ATTR_UNUSED:
        case ATTR_SECTION:
        case ATTR_ALIGNED:
            if (first) iface << " __attribute__((";
            else iface << ", ";
            iface << A->kind2str();
            if (Arg) {
                iface << '(';
                Arg->printLiteral(iface);
                iface << ')';
            }
            first = false;
            break;
        }
    }
    if (!first) iface << "))";
}

bool InterfaceGenerator::EmitAsStatic(const Decl* D) const {
    if (!D->isPublic()) return true;
    if (D->isExported()) return false;
    return false;
}

